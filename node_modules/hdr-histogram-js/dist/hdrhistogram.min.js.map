{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///hdrhistogram.min.js","webpack:///webpack/bootstrap 615e0f034f75e390c604","webpack:///./src/AbstractHistogram.ts","webpack:///./src/AbstractHistogramBase.ts","webpack:///./src/ByteBuffer.ts","webpack:///./src/Int32Histogram.ts","webpack:///./src/encoding.ts","webpack:///./src/AbstractHistogramIterator.ts","webpack:///./src/formatters.ts","webpack:///external \"pako\"","webpack:///./~/base64-js/index.js","webpack:///./src/EncodableHistogram.ts","webpack:///./src/Float64Histogram.ts","webpack:///./src/HistogramIterationValue.ts","webpack:///./src/HistogramLogReader.ts","webpack:///./src/HistogramLogWriter.ts","webpack:///./src/Int16Histogram.ts","webpack:///./src/Int8Histogram.ts","webpack:///./src/PercentileIterator.ts","webpack:///./src/RecordedValuesIterator.ts","webpack:///./src/Recorder.ts","webpack:///./src/ZigZagEncoding.ts","webpack:///./src/index.ts","webpack:///./src/ulp.ts"],"names":["root","factory","exports","module","require","define","amd","hdr","pako","this","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","AbstractHistogramBase_1","ByteBuffer_1","RecordedValuesIterator_1","PercentileIterator_1","formatters_1","ZigZagEncoding_1","ulp_1","pow","Math","floor","ceil","log2","max","min","V2EncodingCookieBase","V2CompressedEncodingCookieBase","V2maxWordSizeInBytes","encodingCookie","compressedEncodingCookie","AbstractHistogram","_super","lowestDiscernibleValue","highestTrackableValue","numberOfSignificantValueDigits","_this","maxValue","minNonZeroValue","Number","MAX_SAFE_INTEGER","Error","identity","AbstractHistogramBase","identityBuilder","init","updatedMaxValue","internalValue","unitMagnitudeMask","updateMinNonZeroValue","lowestDiscernibleValueRounded","resetMinNonZeroValue","integerToDoubleValueConversionRatio","normalizingIndexOffset","setNormalizingIndexOffset","largestValueWithSingleUnitResolution","unitMagnitude","subBucketCountMagnitude","subBucketHalfCountMagnitude","subBucketCount","subBucketHalfCount","subBucketMask","establishSize","leadingZeroCountBase","percentileIterator","default","recordedValuesIterator","newHighestTrackableValue","countsArrayLength","determineArrayLengthNeeded","bucketCount","getBucketsNeededToCoverValue","getLengthForNumberOfBuckets","numberOfBuckets","lengthNeeded","smallestUntrackableValue","bucketsNeeded","recordValue","recordSingleValue","countsIndex","countsArrayIndex","handleRecordException","incrementCountAtIndex","updateMinAndMax","incrementTotalCount","count","autoResize","resize","addToCountAtIndex","highestEquivalentValue","valueFromIndex","bucketIndex","getBucketIndex","subBucketIndex","getSubBucketIndex","computeCountsArrayIndex","bucketBaseIndex","offsetInBucket","getValueAtPercentile","percentile","requestedPercentile","fpCountAtPercentile","getTotalCount","countAtPercentile","totalToCurrentIndex","i","getCountAtIndex","valueAtIndex","lowestEquivalentValue","valueFromIndexes","index","thisValueBaseLevel","nextNonEquivalentValue","sizeOfEquivalentValueRange","distanceToNextValue","medianEquivalentValue","getMean","reset","totalValue","hasNext","iterationValue","next","valueIteratedTo","countAtValueIteratedTo","getStdDeviation","mean","geometric_deviation_total","deviation","countAddedInThisIterationStep","std_deviation","sqrt","outputPercentileDistribution","percentileTicksPerHalfDistance","outputValueUnitScalingRatio","useCsvFormat","result","iterator","lineFormatter","lastLineFormatter","valueFormatter_1","floatFormatter","percentileFormatter_1","lastFormatter_1","percentileLevelIteratedTo","totalCountToThisValue","valueFormatter_2","percentileFormatter_2","totalCountFormatter_1","integerFormatter","lastFormatter_2","formatter","max_1","intFormatter","totalCount","getEstimatedFootprintInBytes","_getEstimatedFootprintInBytes","recordSingleValueWithExpectedInterval","expectedIntervalBetweenValueSamples","missingValue","recordCountAtValue","addToTotalCount","recordValueWithCount","recordValueWithExpectedInterval","recordValueWithCountAndExpectedInterval","addWhileCorrectingForCoordinatedOmission","otherHistogram","toHistogram","otherValues","v","add","highestRecordableValue","observedOtherTotalCount","otherCount","setTotalCount","otherMaxIndex","startTimeStampMsec","endTimeStampMsec","getCountAtValue","subtract","otherValue","establishInternalTackingValues","fillBufferFromCountsArray","buffer","countsLimit","srcIndex","zerosCount","encode","encodeIntoByteBuffer","initialPosition","position","putInt32","putInt64","payloadStartPosition","backupIndex","fillCountsArrayFromSourceBuffer","sourceBuffer","lengthInBytes","wordSizeInBytes","dstIndex","endPosition","decode","setCountAtIndex","lengthToCover","MAX_VALUE","maxIndex","minNonZeroIndex","observedTotalCount","countAtIndex","getCookieBase","cookie","getWordSizeInBytesFromCookie","sizeByte","decodeFromByteBuffer","histogramConstr","minBarForHighestTrackableValue","payloadLengthInBytes","lowestTrackableUnitValue","getInt32","getInt64","histogram","filledLength","decodeFromCompressedByteBuffer","initialTargetPosition","lengthOfCompressedContents","uncompressedBuffer","inflate","data","slice","encodeIntoCompressedByteBuffer","targetBuffer","compressionLevel","intermediateUncompressedByteBuffer","allocate","uncompressedLength","compressionOptions","level","compressedArray","deflate","byteLength","putArray","clearCounts","tag","NO_TAG","EncodableHistogram_1","EncodableHistogram","TWO_POW_32","ByteBuffer","int32ArrayForConvert","Uint32Array","int8ArrayForConvert","Uint8Array","size","put","length","oldArray","set","reverse","array","get","high","low","resetPosition","AbstractHistogram_1","Int32Histogram","counts","fill","currentCount","newCount","MIN_SAFE_INTEGER","newCounts","copyCorrectedForCoordinatedOmission","copy","Int32Histogram_1","base64","decodeFromCompressedBase64","base64String","toByteArray","encodeIntoBase64String","bufferSize","encodedBuffer","fromByteArray","HistogramIterationValue_1","AbstractHistogramIterator","currentIterationValue","resetIterator","savedHistogramTotalRawCount","arrayTotalCount","currentIndex","currentValueAtIndex","nextValueAtIndex","prevValueIteratedTo","totalCountToPrevIndex","totalCountToCurrentIndex","totalValueToCurrentIndex","countAtThisValue","freshSubBucket","exhaustedSubBuckets","reachedIterationLevel","getValueIteratedTo","assign","valueIteratedFrom","totalValueToThisValue","getPercentileIteratedTo","incrementIterationLevel","incrementSubBucket","getPercentileIteratedFrom","leftPadding","input","repeat","padding","integer","fractionDigits","numberFormatter","Intl","NumberFormat","maximumFractionDigits","minimumFractionDigits","useGrouping","float","format","placeHoldersCount","b64","len","l","tmp","placeHolders","arr","Arr","L","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2","code","Float64Histogram","Float64Array","HistogramIterationValue","encoding_1","TAG_PREFIX","TAG_PREFIX_LENGTH","HistogramLogReader","logContent","lines","splitLines","currentLineIndex","nextIntervalHistogram","rangeStartTimeSec","rangeEndTimeSec","currentLine","startsWith","parseStartTimeFromLine","parseBaseTimeFromLine","includes","tokens","split","firstToken","substring","shift","rawLogTimeStampInSec","rawIntervalLengthSec","base64Histogram","logTimeStampInSec","parseFloat","baseTimeSec","startTimeSec","intervalLengthSec","line","shouldIncludeNoTag","find","listTags","content","tags","filter","map","indexOf","tagsWithoutDuplicates","Set","from","unshift","HISTOGRAM_LOG_FORMAT_VERSION","timeFormatter","HistogramLogWriter","log","baseTime","outputIntervalHistogram","startTimeStampSec","endTimeStampSec","maxValueUnitRatio","duration","lineContent","outputComment","comment","outputStartTime","startTimeMsec","Date","outputLegend","outputLogFormatVersion","Int16Histogram","Uint16Array","Int8Histogram","AbstractHistogramIterator_1","PercentileIterator","percentileLevelToIterateTo","percentileLevelToIterateFrom","reachedLastRecordedValue","doReset","percentileReportingTicks","currentPercentile","RecordedValuesIterator","visitedIndex","Recorder","clock","getTime","activeHistogram","idGenerator","containingInstanceId","getIntervalHistogram","histogramToRecycle","histogramToRecycleWithId","inactiveHistogram","performIntervalSample","sampledHistogram","getIntervalHistogramInto","targetHistogram","tempHistogram","currentTimeInMs","TWO_POW_7","TWO_POW_14","TWO_POW_21","TWO_POW_28","TWO_POW_35","TWO_POW_42","TWO_POW_49","TWO_POW_56","ZigZagEncoding","Int8Histogram_1","Int16Histogram_1","Float64Histogram_1","Histogram","HistogramLogReader_1","HistogramLogWriter_1","Recorder_1","defaultRequest","bitBucketSize","build","request","parameters","ulp","x"],"mappings":"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","file":"hdrhistogram.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(21);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar AbstractHistogramBase_1 = __webpack_require__(2);\r\n\tvar ByteBuffer_1 = __webpack_require__(3);\r\n\tvar RecordedValuesIterator_1 = __webpack_require__(18);\r\n\tvar PercentileIterator_1 = __webpack_require__(17);\r\n\tvar formatters_1 = __webpack_require__(7);\r\n\tvar ZigZagEncoding_1 = __webpack_require__(20);\r\n\tvar ulp_1 = __webpack_require__(22);\r\n\tvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\r\n\tvar V2EncodingCookieBase = 0x1c849303;\r\n\tvar V2CompressedEncodingCookieBase = 0x1c849304;\r\n\tvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\r\n\tvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\r\n\tvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\r\n\tvar AbstractHistogram = /** @class */ (function (_super) {\r\n\t    __extends(AbstractHistogram, _super);\r\n\t    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n\t        var _this = _super.call(this) || this;\r\n\t        _this.maxValue = 0;\r\n\t        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\r\n\t        // Verify argument validity\r\n\t        if (lowestDiscernibleValue < 1) {\r\n\t            throw new Error(\"lowestDiscernibleValue must be >= 1\");\r\n\t        }\r\n\t        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\r\n\t            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue\");\r\n\t        }\r\n\t        if (numberOfSignificantValueDigits < 0 ||\r\n\t            numberOfSignificantValueDigits > 5) {\r\n\t            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\r\n\t        }\r\n\t        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\r\n\t        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\r\n\t        return _this;\r\n\t    }\r\n\t    AbstractHistogram.prototype.updatedMaxValue = function (value) {\r\n\t        var internalValue = value + this.unitMagnitudeMask;\r\n\t        this.maxValue = internalValue;\r\n\t    };\r\n\t    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\r\n\t        if (value <= this.unitMagnitudeMask) {\r\n\t            return;\r\n\t        }\r\n\t        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\r\n\t            this.lowestDiscernibleValueRounded;\r\n\t        this.minNonZeroValue = internalValue;\r\n\t    };\r\n\t    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\r\n\t        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\r\n\t            this.lowestDiscernibleValueRounded;\r\n\t        this.minNonZeroValue =\r\n\t            minNonZeroValue === Number.MAX_SAFE_INTEGER\r\n\t                ? minNonZeroValue\r\n\t                : internalValue;\r\n\t    };\r\n\t    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\r\n\t        this.lowestDiscernibleValue = lowestDiscernibleValue;\r\n\t        this.highestTrackableValue = highestTrackableValue;\r\n\t        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\r\n\t        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\r\n\t        if (normalizingIndexOffset !== 0) {\r\n\t            this.setNormalizingIndexOffset(normalizingIndexOffset);\r\n\t        }\r\n\t        /*\r\n\t        * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\r\n\t        * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\r\n\t        * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\r\n\t        */\r\n\t        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\r\n\t        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\r\n\t        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\r\n\t        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\r\n\t        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\r\n\t        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\r\n\t        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\r\n\t        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\r\n\t        this.subBucketHalfCountMagnitude =\r\n\t            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\r\n\t        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\r\n\t        this.subBucketHalfCount = this.subBucketCount / 2;\r\n\t        this.subBucketMask =\r\n\t            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\r\n\t        this.establishSize(highestTrackableValue);\r\n\t        this.leadingZeroCountBase =\r\n\t            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\r\n\t        this.percentileIterator = new PercentileIterator_1.default(this, 1);\r\n\t        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\r\n\t    };\r\n\t    /**\r\n\t     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\r\n\t     *\r\n\t     * <pre>\r\n\t     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\r\n\t     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\r\n\t     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\r\n\t     * ...\r\n\t     * </pre>\r\n\t     *\r\n\t     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\r\n\t     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\r\n\t     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\r\n\t     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\r\n\t     * values as it has better precision.\r\n\t     */\r\n\t    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\r\n\t        // establish counts array length:\r\n\t        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\r\n\t        // establish exponent range needed to support the trackable value with no overflow:\r\n\t        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\r\n\t        // establish the new highest trackable value:\r\n\t        this.highestTrackableValue = newHighestTrackableValue;\r\n\t    };\r\n\t    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\r\n\t        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\r\n\t            throw new Error(\"highestTrackableValue (\" +\r\n\t                highestTrackableValue +\r\n\t                \") cannot be < (2 * lowestDiscernibleValue)\");\r\n\t        }\r\n\t        //determine counts array length needed:\r\n\t        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\r\n\t        return countsArrayLength;\r\n\t    };\r\n\t    /**\r\n\t     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\r\n\t     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\r\n\t     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\r\n\t     * value if we consider the sub-bucket length to be halved.\r\n\t     */\r\n\t    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\r\n\t        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\r\n\t        return lengthNeeded;\r\n\t    };\r\n\t    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\r\n\t        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\r\n\t        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\r\n\t        // always have at least 1 bucket\r\n\t        var bucketsNeeded = 1;\r\n\t        while (smallestUntrackableValue <= value) {\r\n\t            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\r\n\t                // TODO check array max size in JavaScript\r\n\t                // next shift will overflow, meaning that bucket could represent values up to ones greater than\r\n\t                // Number.MAX_SAFE_INTEGER, so it's the last bucket\r\n\t                return bucketsNeeded + 1;\r\n\t            }\r\n\t            smallestUntrackableValue = smallestUntrackableValue * 2;\r\n\t            bucketsNeeded++;\r\n\t        }\r\n\t        return bucketsNeeded;\r\n\t    };\r\n\t    /**\r\n\t     * Record a value in the histogram\r\n\t     *\r\n\t     * @param value The value to be recorded\r\n\t     * @throws may throw Error if value is exceeds highestTrackableValue\r\n\t     */\r\n\t    AbstractHistogram.prototype.recordValue = function (value) {\r\n\t        this.recordSingleValue(value);\r\n\t    };\r\n\t    AbstractHistogram.prototype.recordSingleValue = function (value) {\r\n\t        var countsIndex = this.countsArrayIndex(value);\r\n\t        if (countsIndex >= this.countsArrayLength) {\r\n\t            this.handleRecordException(1, value);\r\n\t        }\r\n\t        else {\r\n\t            this.incrementCountAtIndex(countsIndex);\r\n\t        }\r\n\t        this.updateMinAndMax(value);\r\n\t        this.incrementTotalCount();\r\n\t    };\r\n\t    AbstractHistogram.prototype.handleRecordException = function (count, value) {\r\n\t        if (!this.autoResize) {\r\n\t            throw \"Value \" + value + \" is outside of histogram covered range\";\r\n\t        }\r\n\t        this.resize(value);\r\n\t        var countsIndex = this.countsArrayIndex(value);\r\n\t        this.addToCountAtIndex(countsIndex, count);\r\n\t        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\r\n\t    };\r\n\t    AbstractHistogram.prototype.countsArrayIndex = function (value) {\r\n\t        if (value < 0) {\r\n\t            throw new Error(\"Histogram recorded value cannot be negative.\");\r\n\t        }\r\n\t        var bucketIndex = this.getBucketIndex(value);\r\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n\t        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\r\n\t    };\r\n\t    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\r\n\t        // TODO\r\n\t        //assert(subBucketIndex < subBucketCount);\r\n\t        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\r\n\t        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\r\n\t        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\r\n\t        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\r\n\t        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\r\n\t        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\r\n\t        // However, this works out since we give bucket 0 twice as much space.\r\n\t        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\r\n\t        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\r\n\t        return bucketBaseIndex + offsetInBucket;\r\n\t    };\r\n\t    /**\r\n\t     * @return the lowest (and therefore highest precision) bucket index that can represent the value\r\n\t     */\r\n\t    AbstractHistogram.prototype.getBucketIndex = function (value) {\r\n\t        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\r\n\t        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\r\n\t        // The mask maps small values to bucket 0.\r\n\t        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\r\n\t        return max(floor(log2(value)) -\r\n\t            this.subBucketHalfCountMagnitude -\r\n\t            this.unitMagnitude, 0);\r\n\t    };\r\n\t    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\r\n\t        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\r\n\t        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\r\n\t        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\r\n\t        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\r\n\t        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\r\n\t        // and therefore in the top half of subBucketCount.\r\n\t        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\r\n\t    };\r\n\t    AbstractHistogram.prototype.updateMinAndMax = function (value) {\r\n\t        if (value > this.maxValue) {\r\n\t            this.updatedMaxValue(value);\r\n\t        }\r\n\t        if (value < this.minNonZeroValue && value !== 0) {\r\n\t            this.updateMinNonZeroValue(value);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the value at a given percentile.\r\n\t     * When the given percentile is &gt; 0.0, the value returned is the value that the given\r\n\t     * percentage of the overall recorded value entries in the histogram are either smaller than\r\n\t     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\r\n\t     * entries in the histogram are either larger than or equivalent to.\r\n\t     * <p>\r\n\t     * Note that two values are \"equivalent\" in this statement if\r\n\t     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\r\n\t     *\r\n\t     * @param percentile  The percentile for which to return the associated value\r\n\t     * @return The value that the given percentage of the overall recorded value entries in the\r\n\t     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\r\n\t     * value that all value entries in the histogram are either larger than or equivalent to.\r\n\t     */\r\n\t    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\r\n\t        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\r\n\t        // round count up to nearest integer, to ensure that the largest value that the requested percentile\r\n\t        // of overall recorded values is actually included. However, this must be done with care:\r\n\t        //\r\n\t        // First, Compute fp value for count at the requested percentile. Note that fp result end up\r\n\t        // being 1 ulp larger than the correct integer count for this percentile:\r\n\t        var fpCountAtPercentile = requestedPercentile / 100.0 * this.getTotalCount();\r\n\t        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\r\n\t        // making us skip a count:\r\n\t        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\r\n\t        1 // Make sure we at least reach the first recorded entry\r\n\t        );\r\n\t        var totalToCurrentIndex = 0;\r\n\t        for (var i = 0; i < this.countsArrayLength; i++) {\r\n\t            totalToCurrentIndex += this.getCountAtIndex(i);\r\n\t            if (totalToCurrentIndex >= countAtPercentile) {\r\n\t                var valueAtIndex = this.valueFromIndex(i);\r\n\t                return percentile === 0.0\r\n\t                    ? this.lowestEquivalentValue(valueAtIndex)\r\n\t                    : this.highestEquivalentValue(valueAtIndex);\r\n\t            }\r\n\t        }\r\n\t        return 0;\r\n\t    };\r\n\t    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\r\n\t        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\r\n\t    };\r\n\t    AbstractHistogram.prototype.valueFromIndex = function (index) {\r\n\t        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\r\n\t        var subBucketIndex = index % this.subBucketHalfCount + this.subBucketHalfCount;\r\n\t        if (bucketIndex < 0) {\r\n\t            subBucketIndex -= this.subBucketHalfCount;\r\n\t            bucketIndex = 0;\r\n\t        }\r\n\t        return this.valueFromIndexes(bucketIndex, subBucketIndex);\r\n\t    };\r\n\t    /**\r\n\t     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\r\n\t     * Where \"equivalent\" means that value samples recorded for any two\r\n\t     * equivalent values are counted in a common total count.\r\n\t     *\r\n\t     * @param value The given value\r\n\t     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\r\n\t     */\r\n\t    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\r\n\t        var bucketIndex = this.getBucketIndex(value);\r\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n\t        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\r\n\t        return thisValueBaseLevel;\r\n\t    };\r\n\t    /**\r\n\t     * Get the highest value that is equivalent to the given value within the histogram's resolution.\r\n\t     * Where \"equivalent\" means that value samples recorded for any two\r\n\t     * equivalent values are counted in a common total count.\r\n\t     *\r\n\t     * @param value The given value\r\n\t     * @return The highest value that is equivalent to the given value within the histogram's resolution.\r\n\t     */\r\n\t    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\r\n\t        return this.nextNonEquivalentValue(value) - 1;\r\n\t    };\r\n\t    /**\r\n\t     * Get the next value that is not equivalent to the given value within the histogram's resolution.\r\n\t     * Where \"equivalent\" means that value samples recorded for any two\r\n\t     * equivalent values are counted in a common total count.\r\n\t     *\r\n\t     * @param value The given value\r\n\t     * @return The next value that is not equivalent to the given value within the histogram's resolution.\r\n\t     */\r\n\t    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\r\n\t        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\r\n\t    };\r\n\t    /**\r\n\t     * Get the size (in value units) of the range of values that are equivalent to the given value within the\r\n\t     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\r\n\t     * equivalent values are counted in a common total count.\r\n\t     *\r\n\t     * @param value The given value\r\n\t     * @return The size of the range of values equivalent to the given value.\r\n\t     */\r\n\t    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\r\n\t        var bucketIndex = this.getBucketIndex(value);\r\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n\t        var distanceToNextValue = pow(2, this.unitMagnitude +\r\n\t            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\r\n\t        return distanceToNextValue;\r\n\t    };\r\n\t    /**\r\n\t     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\r\n\t     * Where \"equivalent\" means that value samples recorded for any two\r\n\t     * equivalent values are counted in a common total count.\r\n\t     *\r\n\t     * @param value The given value\r\n\t     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\r\n\t     */\r\n\t    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\r\n\t        return (this.lowestEquivalentValue(value) +\r\n\t            floor(this.sizeOfEquivalentValueRange(value) / 2));\r\n\t    };\r\n\t    /**\r\n\t     * Get the computed mean value of all recorded values in the histogram\r\n\t     *\r\n\t     * @return the mean value (in value units) of the histogram data\r\n\t     */\r\n\t    AbstractHistogram.prototype.getMean = function () {\r\n\t        if (this.getTotalCount() === 0) {\r\n\t            return 0;\r\n\t        }\r\n\t        this.recordedValuesIterator.reset();\r\n\t        var totalValue = 0;\r\n\t        while (this.recordedValuesIterator.hasNext()) {\r\n\t            var iterationValue = this.recordedValuesIterator.next();\r\n\t            totalValue +=\r\n\t                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\r\n\t                    iterationValue.countAtValueIteratedTo;\r\n\t        }\r\n\t        return totalValue * 1.0 / this.getTotalCount();\r\n\t    };\r\n\t    /**\r\n\t     * Get the computed standard deviation of all recorded values in the histogram\r\n\t     *\r\n\t     * @return the standard deviation (in value units) of the histogram data\r\n\t     */\r\n\t    AbstractHistogram.prototype.getStdDeviation = function () {\r\n\t        if (this.getTotalCount() === 0) {\r\n\t            return 0;\r\n\t        }\r\n\t        var mean = this.getMean();\r\n\t        var geometric_deviation_total = 0.0;\r\n\t        this.recordedValuesIterator.reset();\r\n\t        while (this.recordedValuesIterator.hasNext()) {\r\n\t            var iterationValue = this.recordedValuesIterator.next();\r\n\t            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\r\n\t            geometric_deviation_total +=\r\n\t                deviation * deviation * iterationValue.countAddedInThisIterationStep;\r\n\t        }\r\n\t        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\r\n\t        return std_deviation;\r\n\t    };\r\n\t    /**\r\n\t     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\r\n\t     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\r\n\t     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\r\n\t     *\r\n\t     * @param printStream    Stream into which the distribution will be output\r\n\t     * <p>\r\n\t     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\r\n\t     * <p>\r\n\t     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\r\n\t     *                                     output\r\n\t     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\r\n\t     */\r\n\t    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\r\n\t        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\r\n\t        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\r\n\t        if (useCsvFormat === void 0) { useCsvFormat = false; }\r\n\t        var result = \"\";\r\n\t        if (useCsvFormat) {\r\n\t            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\r\n\t        }\r\n\t        else {\r\n\t            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\r\n\t        }\r\n\t        var iterator = this.percentileIterator;\r\n\t        iterator.reset(percentileTicksPerHalfDistance);\r\n\t        var lineFormatter;\r\n\t        var lastLineFormatter;\r\n\t        if (useCsvFormat) {\r\n\t            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\r\n\t            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\r\n\t            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\r\n\t            lineFormatter = function (iterationValue) {\r\n\t                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n\t                    \",\" +\r\n\t                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\r\n\t                    \",\" +\r\n\t                    iterationValue.totalCountToThisValue +\r\n\t                    \",\" +\r\n\t                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\r\n\t                    \"\\n\";\r\n\t            };\r\n\t            lastLineFormatter = function (iterationValue) {\r\n\t                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n\t                    \",\" +\r\n\t                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\r\n\t                    \",\" +\r\n\t                    iterationValue.totalCountToThisValue +\r\n\t                    \",Infinity\\n\";\r\n\t            };\r\n\t        }\r\n\t        else {\r\n\t            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\r\n\t            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\r\n\t            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\r\n\t            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\r\n\t            lineFormatter = function (iterationValue) {\r\n\t                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n\t                    \" \" +\r\n\t                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\r\n\t                    \" \" +\r\n\t                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\r\n\t                    \" \" +\r\n\t                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\r\n\t                    \"\\n\";\r\n\t            };\r\n\t            lastLineFormatter = function (iterationValue) {\r\n\t                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n\t                    \" \" +\r\n\t                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\r\n\t                    \" \" +\r\n\t                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\r\n\t                    \"\\n\";\r\n\t            };\r\n\t        }\r\n\t        while (iterator.hasNext()) {\r\n\t            var iterationValue = iterator.next();\r\n\t            if (iterationValue.percentileLevelIteratedTo < 100) {\r\n\t                result += lineFormatter(iterationValue);\r\n\t            }\r\n\t            else {\r\n\t                result += lastLineFormatter(iterationValue);\r\n\t            }\r\n\t        }\r\n\t        if (!useCsvFormat) {\r\n\t            // Calculate and output mean and std. deviation.\r\n\t            // Note: mean/std. deviation numbers are very often completely irrelevant when\r\n\t            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\r\n\t            // response time distribution associated with GC pauses). However, reporting these numbers\r\n\t            // can be very useful for contrasting with the detailed percentile distribution\r\n\t            // reported by outputPercentileDistribution(). It is not at all surprising to find\r\n\t            // percentile distributions where results fall many tens or even hundreds of standard\r\n\t            // deviations away from the mean - such results simply indicate that the data sampled\r\n\t            // exhibits a very non-normal distribution, highlighting situations for which the std.\r\n\t            // deviation metric is a useless indicator.\r\n\t            //\r\n\t            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\r\n\t            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\r\n\t            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\r\n\t            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\r\n\t            var intFormatter = formatters_1.integerFormatter(12);\r\n\t            var totalCount = intFormatter(this.getTotalCount());\r\n\t            var bucketCount = intFormatter(this.bucketCount);\r\n\t            var subBucketCount = intFormatter(this.subBucketCount);\r\n\t            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\r\n\t        }\r\n\t        return result;\r\n\t    };\r\n\t    /**\r\n\t     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\r\n\t     *\r\n\t     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\r\n\t     */\r\n\t    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\r\n\t        return this._getEstimatedFootprintInBytes();\r\n\t    };\r\n\t    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n\t        this.recordSingleValue(value);\r\n\t        if (expectedIntervalBetweenValueSamples <= 0) {\r\n\t            return;\r\n\t        }\r\n\t        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\r\n\t            this.recordSingleValue(missingValue);\r\n\t        }\r\n\t    };\r\n\t    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\r\n\t        var countsIndex = this.countsArrayIndex(value);\r\n\t        if (countsIndex >= this.countsArrayLength) {\r\n\t            this.handleRecordException(count, value);\r\n\t        }\r\n\t        else {\r\n\t            this.addToCountAtIndex(countsIndex, count);\r\n\t        }\r\n\t        this.updateMinAndMax(value);\r\n\t        this.addToTotalCount(count);\r\n\t    };\r\n\t    /**\r\n\t     * Record a value in the histogram (adding to the value's current count)\r\n\t     *\r\n\t     * @param value The value to be recorded\r\n\t     * @param count The number of occurrences of this value to record\r\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n\t     */\r\n\t    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\r\n\t        this.recordCountAtValue(count, value);\r\n\t    };\r\n\t    /**\r\n\t     * Record a value in the histogram.\r\n\t     * <p>\r\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n\t     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\r\n\t     * (down to the expectedIntervalBetweenValueSamples) value records.\r\n\t     * <p>\r\n\t     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\r\n\t     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\r\n\t     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\r\n\t     * for the same coordinated omission issue.\r\n\t     * <p>\r\n\t     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\r\n\t     * important.\r\n\t     *\r\n\t     * @param value The value to record\r\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n\t     *                                           auto-generated value records as appropriate if value is larger\r\n\t     *                                           than expectedIntervalBetweenValueSamples\r\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n\t     */\r\n\t    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n\t        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\r\n\t    };\r\n\t    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\r\n\t        this.recordCountAtValue(count, value);\r\n\t        if (expectedIntervalBetweenValueSamples <= 0) {\r\n\t            return;\r\n\t        }\r\n\t        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\r\n\t            this.recordCountAtValue(count, missingValue);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\r\n\t     * <p>\r\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n\t     * interval between value samples, the values added will include an auto-generated additional series of\r\n\t     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\r\n\t     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\r\n\t     *\r\n\t     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\r\n\t     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\r\n\t     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\r\n\t     * for the same coordinated omission issue.\r\n\t     * by\r\n\t     * <p>\r\n\t     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\r\n\t     * important.\r\n\t     *\r\n\t     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\r\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n\t     *                                           auto-generated value records as appropriate if value is larger\r\n\t     *                                           than expectedIntervalBetweenValueSamples\r\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\r\n\t     */\r\n\t    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\r\n\t        var toHistogram = this;\r\n\t        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\r\n\t        while (otherValues.hasNext()) {\r\n\t            var v = otherValues.next();\r\n\t            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Add the contents of another histogram to this one.\r\n\t     * <p>\r\n\t     * As part of adding the contents, the start/end timestamp range of this histogram will be\r\n\t     * extended to include the start/end timestamp range of the other histogram.\r\n\t     *\r\n\t     * @param otherHistogram The other histogram.\r\n\t     * @throws (may throw) if values in fromHistogram's are\r\n\t     * higher than highestTrackableValue.\r\n\t     */\r\n\t    AbstractHistogram.prototype.add = function (otherHistogram) {\r\n\t        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\r\n\t        if (highestRecordableValue < otherHistogram.maxValue) {\r\n\t            if (!this.autoResize) {\r\n\t                throw \"The other histogram includes values that do not fit in this histogram's range.\";\r\n\t            }\r\n\t            this.resize(otherHistogram.maxValue);\r\n\t        }\r\n\t        if (this.bucketCount === otherHistogram.bucketCount &&\r\n\t            this.subBucketCount === otherHistogram.subBucketCount &&\r\n\t            this.unitMagnitude === otherHistogram.unitMagnitude) {\r\n\t            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\r\n\t            var observedOtherTotalCount = 0;\r\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\r\n\t                if (otherCount > 0) {\r\n\t                    this.addToCountAtIndex(i, otherCount);\r\n\t                    observedOtherTotalCount += otherCount;\r\n\t                }\r\n\t            }\r\n\t            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\r\n\t            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\r\n\t            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\r\n\t        }\r\n\t        else {\r\n\t            // Arrays are not a direct match (or the other could change on the fly in some valid way),\r\n\t            // so we can't just stream through and add them. Instead, go through the array and add each\r\n\t            // non-zero value found at it's proper value:\r\n\t            // Do max value first, to avoid max value updates on each iteration:\r\n\t            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\r\n\t            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\r\n\t            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\r\n\t            // Record the remaining values, up to but not including the max value:\r\n\t            for (var i = 0; i < otherMaxIndex; i++) {\r\n\t                otherCount = otherHistogram.getCountAtIndex(i);\r\n\t                if (otherCount > 0) {\r\n\t                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\r\n\t        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\r\n\t    };\r\n\t    /**\r\n\t     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\r\n\t     *\r\n\t     * @param value The value for which to provide the recorded count\r\n\t     * @return The total count of values recorded in the histogram within the value range that is\r\n\t     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\r\n\t     */\r\n\t    AbstractHistogram.prototype.getCountAtValue = function (value) {\r\n\t        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\r\n\t        return this.getCountAtIndex(index);\r\n\t    };\r\n\t    /**\r\n\t     * Subtract the contents of another histogram from this one.\r\n\t     * <p>\r\n\t     * The start/end timestamps of this histogram will remain unchanged.\r\n\t     *\r\n\t     * @param otherHistogram The other histogram.\r\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\r\n\t     *\r\n\t     */\r\n\t    AbstractHistogram.prototype.subtract = function (otherHistogram) {\r\n\t        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\r\n\t        if (highestRecordableValue < otherHistogram.maxValue) {\r\n\t            if (!this.autoResize) {\r\n\t                throw \"The other histogram includes values that do not fit in this histogram's range.\";\r\n\t            }\r\n\t            this.resize(otherHistogram.maxValue);\r\n\t        }\r\n\t        if (this.bucketCount === otherHistogram.bucketCount &&\r\n\t            this.subBucketCount === otherHistogram.subBucketCount &&\r\n\t            this.unitMagnitude === otherHistogram.unitMagnitude) {\r\n\t            // optim\r\n\t            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\r\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\r\n\t                if (otherCount > 0) {\r\n\t                    this.addToCountAtIndex(i, -otherCount);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\r\n\t                if (otherCount > 0) {\r\n\t                    var otherValue = otherHistogram.valueFromIndex(i);\r\n\t                    if (this.getCountAtValue(otherValue) < otherCount) {\r\n\t                        throw \"otherHistogram count (\" +\r\n\t                            otherCount +\r\n\t                            \") at value \" +\r\n\t                            otherValue +\r\n\t                            \" is larger than this one's (\" +\r\n\t                            this.getCountAtValue(otherValue) +\r\n\t                            \")\";\r\n\t                    }\r\n\t                    this.recordCountAtValue(-otherCount, otherValue);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        // With subtraction, the max and minNonZero values could have changed:\r\n\t        if (this.getCountAtValue(this.maxValue) <= 0 ||\r\n\t            this.getCountAtValue(this.minNonZeroValue) <= 0) {\r\n\t            this.establishInternalTackingValues();\r\n\t        }\r\n\t    };\r\n\t    AbstractHistogram.prototype.fillBufferFromCountsArray = function (buffer) {\r\n\t        var countsLimit = this.countsArrayIndex(this.maxValue) + 1;\r\n\t        var srcIndex = 0;\r\n\t        while (srcIndex < countsLimit) {\r\n\t            // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\r\n\t            // while negative values indicate a repeat zero counts.\r\n\t            var count = this.getCountAtIndex(srcIndex++);\r\n\t            if (count < 0) {\r\n\t                throw \"Cannot encode histogram containing negative counts (\" +\r\n\t                    count +\r\n\t                    \") at index \" +\r\n\t                    srcIndex +\r\n\t                    \", corresponding the value range [\" +\r\n\t                    this.lowestEquivalentValue(this.valueFromIndex(srcIndex)) +\r\n\t                    \",\" +\r\n\t                    this.nextNonEquivalentValue(this.valueFromIndex(srcIndex)) +\r\n\t                    \")\";\r\n\t            }\r\n\t            // Count trailing 0s (which follow this count):\r\n\t            var zerosCount = 0;\r\n\t            if (count == 0) {\r\n\t                zerosCount = 1;\r\n\t                while (srcIndex < countsLimit && this.getCountAtIndex(srcIndex) == 0) {\r\n\t                    zerosCount++;\r\n\t                    srcIndex++;\r\n\t                }\r\n\t            }\r\n\t            if (zerosCount > 1) {\r\n\t                ZigZagEncoding_1.default.encode(buffer, -zerosCount);\r\n\t            }\r\n\t            else {\r\n\t                ZigZagEncoding_1.default.encode(buffer, count);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Encode this histogram into a ByteBuffer\r\n\t     * @param buffer The buffer to encode into\r\n\t     * @return The number of bytes written to the buffer\r\n\t     */\r\n\t    AbstractHistogram.prototype.encodeIntoByteBuffer = function (buffer) {\r\n\t        var initialPosition = buffer.position;\r\n\t        buffer.putInt32(encodingCookie);\r\n\t        buffer.putInt32(0); // Placeholder for payload length in bytes.\r\n\t        buffer.putInt32(1);\r\n\t        buffer.putInt32(this.numberOfSignificantValueDigits);\r\n\t        buffer.putInt64(this.lowestDiscernibleValue);\r\n\t        buffer.putInt64(this.highestTrackableValue);\r\n\t        buffer.putInt64(1);\r\n\t        var payloadStartPosition = buffer.position;\r\n\t        this.fillBufferFromCountsArray(buffer);\r\n\t        var backupIndex = buffer.position;\r\n\t        buffer.position = initialPosition + 4;\r\n\t        buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\r\n\t        buffer.position = backupIndex;\r\n\t        return backupIndex - initialPosition;\r\n\t    };\r\n\t    AbstractHistogram.prototype.fillCountsArrayFromSourceBuffer = function (sourceBuffer, lengthInBytes, wordSizeInBytes) {\r\n\t        if (wordSizeInBytes != 2 &&\r\n\t            wordSizeInBytes != 4 &&\r\n\t            wordSizeInBytes != 8 &&\r\n\t            wordSizeInBytes != V2maxWordSizeInBytes) {\r\n\t            throw \"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\r\n\t                V2maxWordSizeInBytes +\r\n\t                \") bytes\";\r\n\t        }\r\n\t        var dstIndex = 0;\r\n\t        var endPosition = sourceBuffer.position + lengthInBytes;\r\n\t        while (sourceBuffer.position < endPosition) {\r\n\t            var zerosCount = 0;\r\n\t            var count = ZigZagEncoding_1.default.decode(sourceBuffer);\r\n\t            if (count < 0) {\r\n\t                zerosCount = -count;\r\n\t                dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\r\n\t            }\r\n\t            else {\r\n\t                this.setCountAtIndex(dstIndex++, count);\r\n\t            }\r\n\t        }\r\n\t        return dstIndex; // this is the destination length\r\n\t    };\r\n\t    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\r\n\t        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\r\n\t        this.maxValue = 0;\r\n\t        this.minNonZeroValue = Number.MAX_VALUE;\r\n\t        var maxIndex = -1;\r\n\t        var minNonZeroIndex = -1;\r\n\t        var observedTotalCount = 0;\r\n\t        for (var index = 0; index < lengthToCover; index++) {\r\n\t            var countAtIndex = this.getCountAtIndex(index);\r\n\t            if (countAtIndex > 0) {\r\n\t                observedTotalCount += countAtIndex;\r\n\t                maxIndex = index;\r\n\t                if (minNonZeroIndex == -1 && index != 0) {\r\n\t                    minNonZeroIndex = index;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if (maxIndex >= 0) {\r\n\t            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\r\n\t        }\r\n\t        if (minNonZeroIndex >= 0) {\r\n\t            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\r\n\t        }\r\n\t        this.setTotalCount(observedTotalCount);\r\n\t    };\r\n\t    AbstractHistogram.getCookieBase = function (cookie) {\r\n\t        return cookie & ~0xf0;\r\n\t    };\r\n\t    AbstractHistogram.getWordSizeInBytesFromCookie = function (cookie) {\r\n\t        if (this.getCookieBase(cookie) == V2EncodingCookieBase ||\r\n\t            this.getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\r\n\t            return V2maxWordSizeInBytes;\r\n\t        }\r\n\t        var sizeByte = (cookie & 0xf0) >> 4;\r\n\t        return sizeByte & 0xe;\r\n\t    };\r\n\t    AbstractHistogram.decodeFromByteBuffer = function (buffer, histogramConstr, minBarForHighestTrackableValue) {\r\n\t        var cookie = buffer.getInt32();\r\n\t        var payloadLengthInBytes;\r\n\t        var numberOfSignificantValueDigits;\r\n\t        var lowestTrackableUnitValue;\r\n\t        var highestTrackableValue;\r\n\t        if (this.getCookieBase(cookie) === V2EncodingCookieBase) {\r\n\t            if (this.getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\r\n\t                throw \"The buffer does not contain a Histogram (no valid cookie found)\";\r\n\t            }\r\n\t            payloadLengthInBytes = buffer.getInt32();\r\n\t            buffer.getInt32(); // normalizingIndexOffset not used\r\n\t            numberOfSignificantValueDigits = buffer.getInt32();\r\n\t            lowestTrackableUnitValue = buffer.getInt64();\r\n\t            highestTrackableValue = buffer.getInt64();\r\n\t            buffer.getInt64(); // integerToDoubleValueConversionRatio not used\r\n\t        }\r\n\t        else {\r\n\t            throw \"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\";\r\n\t        }\r\n\t        highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\r\n\t        var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\r\n\t        var filledLength = histogram.fillCountsArrayFromSourceBuffer(buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\r\n\t        histogram.establishInternalTackingValues(filledLength);\r\n\t        return histogram;\r\n\t    };\r\n\t    AbstractHistogram.decodeFromCompressedByteBuffer = function (buffer, histogramConstr, minBarForHighestTrackableValue) {\r\n\t        var initialTargetPosition = buffer.position;\r\n\t        var cookie = buffer.getInt32();\r\n\t        if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\r\n\t            throw \"Encoding not supported, only V2 is supported\";\r\n\t        }\r\n\t        var lengthOfCompressedContents = buffer.getInt32();\r\n\t        var pako = __webpack_require__(8);\r\n\t        var uncompressedBuffer = pako.inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\r\n\t        return this.decodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\r\n\t    };\r\n\t    /**\r\n\t     * Encode this histogram in compressed form into a byte array\r\n\t     * @param targetBuffer The buffer to encode into\r\n\t     * @return The number of bytes written to the array\r\n\t     */\r\n\t    AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = function (targetBuffer, compressionLevel) {\r\n\t        var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\r\n\t        var uncompressedLength = this.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\r\n\t        targetBuffer.putInt32(compressedEncodingCookie);\r\n\t        var pako = __webpack_require__(8);\r\n\t        var compressionOptions = compressionLevel\r\n\t            ? { level: compressionLevel }\r\n\t            : {};\r\n\t        var compressedArray = pako.deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\r\n\t        targetBuffer.putInt32(compressedArray.byteLength);\r\n\t        targetBuffer.putArray(compressedArray);\r\n\t        return targetBuffer.position;\r\n\t    };\r\n\t    AbstractHistogram.prototype.reset = function () {\r\n\t        this.clearCounts();\r\n\t        this.setTotalCount(0);\r\n\t        this.startTimeStampMsec = 0;\r\n\t        this.endTimeStampMsec = 0;\r\n\t        this.tag = AbstractHistogramBase_1.NO_TAG;\r\n\t        this.maxValue = 0;\r\n\t        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\r\n\t    };\r\n\t    return AbstractHistogram;\r\n\t}(AbstractHistogramBase_1.AbstractHistogramBase));\r\n\texports.default = AbstractHistogram;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar EncodableHistogram_1 = __webpack_require__(10);\r\n\texports.NO_TAG = \"NO TAG\";\r\n\tvar AbstractHistogramBase = /** @class */ (function (_super) {\r\n\t    __extends(AbstractHistogramBase, _super);\r\n\t    //intermediateUncompressedByteBuffer : ByteBuffer = null;\r\n\t    //intermediateUncompressedByteArray : number[] = null;\r\n\t    /* useless ?\r\n\t    getIntegerToDoubleValueConversionRatio(): number {\r\n\t        return this.integerToDoubleValueConversionRatio;\r\n\t    }\r\n\t  \r\n\t    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\r\n\t        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\r\n\t    }*/\r\n\t    function AbstractHistogramBase() {\r\n\t        var _this = _super.call(this) || this;\r\n\t        _this.autoResize = false;\r\n\t        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\r\n\t        _this.endTimeStampMsec = 0;\r\n\t        _this.tag = exports.NO_TAG;\r\n\t        _this.integerToDoubleValueConversionRatio = 1.0;\r\n\t        _this.identity = 0;\r\n\t        _this.highestTrackableValue = 0;\r\n\t        _this.lowestDiscernibleValue = 0;\r\n\t        _this.numberOfSignificantValueDigits = 0;\r\n\t        _this.bucketCount = 0;\r\n\t        _this.subBucketCount = 0;\r\n\t        _this.countsArrayLength = 0;\r\n\t        _this.wordSizeInBytes = 0;\r\n\t        return _this;\r\n\t    }\r\n\t    return AbstractHistogramBase;\r\n\t}(EncodableHistogram_1.EncodableHistogram));\r\n\texports.AbstractHistogramBase = AbstractHistogramBase;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar pow = Math.pow, floor = Math.floor;\r\n\tvar TWO_POW_32 = pow(2, 32);\r\n\t/**\r\n\t * Mimic Java's ByteBufffer with big endian order\r\n\t */\r\n\tvar ByteBuffer = /** @class */ (function () {\r\n\t    function ByteBuffer(data) {\r\n\t        this.position = 0;\r\n\t        this.data = data;\r\n\t        this.int32ArrayForConvert = new Uint32Array(1);\r\n\t        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\r\n\t    }\r\n\t    ByteBuffer.allocate = function (size) {\r\n\t        if (size === void 0) { size = 16; }\r\n\t        return new ByteBuffer(new Uint8Array(size));\r\n\t    };\r\n\t    ByteBuffer.prototype.put = function (value) {\r\n\t        if (this.position === this.data.length) {\r\n\t            var oldArray = this.data;\r\n\t            this.data = new Uint8Array(this.data.length * 2);\r\n\t            this.data.set(oldArray);\r\n\t        }\r\n\t        this.data[this.position] = value;\r\n\t        this.position++;\r\n\t    };\r\n\t    ByteBuffer.prototype.putInt32 = function (value) {\r\n\t        if (this.data.length - this.position < 4) {\r\n\t            var oldArray = this.data;\r\n\t            this.data = new Uint8Array(this.data.length * 2 + 4);\r\n\t            this.data.set(oldArray);\r\n\t        }\r\n\t        this.int32ArrayForConvert[0] = value;\r\n\t        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\r\n\t        this.position += 4;\r\n\t    };\r\n\t    ByteBuffer.prototype.putInt64 = function (value) {\r\n\t        this.putInt32(floor(value / TWO_POW_32));\r\n\t        this.putInt32(value);\r\n\t    };\r\n\t    ByteBuffer.prototype.putArray = function (array) {\r\n\t        if (this.data.length - this.position < array.byteLength) {\r\n\t            var oldArray = this.data;\r\n\t            this.data = new Uint8Array(this.position + array.byteLength);\r\n\t            this.data.set(oldArray);\r\n\t        }\r\n\t        this.data.set(array, this.position);\r\n\t        this.position += array.byteLength;\r\n\t    };\r\n\t    ByteBuffer.prototype.get = function () {\r\n\t        var value = this.data[this.position];\r\n\t        this.position++;\r\n\t        return value;\r\n\t    };\r\n\t    ByteBuffer.prototype.getInt32 = function () {\r\n\t        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\r\n\t        var value = this.int32ArrayForConvert[0];\r\n\t        this.position += 4;\r\n\t        return value;\r\n\t    };\r\n\t    ByteBuffer.prototype.getInt64 = function () {\r\n\t        var high = this.getInt32();\r\n\t        var low = this.getInt32();\r\n\t        return high * TWO_POW_32 + low;\r\n\t    };\r\n\t    ByteBuffer.prototype.resetPosition = function () {\r\n\t        this.position = 0;\r\n\t    };\r\n\t    return ByteBuffer;\r\n\t}());\r\n\texports.default = ByteBuffer;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar AbstractHistogram_1 = __webpack_require__(1);\r\n\tvar Int32Histogram = /** @class */ (function (_super) {\r\n\t    __extends(Int32Histogram, _super);\r\n\t    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n\t        _this.totalCount = 0;\r\n\t        _this.counts = new Uint32Array(_this.countsArrayLength);\r\n\t        return _this;\r\n\t    }\r\n\t    Int32Histogram.prototype.clearCounts = function () {\r\n\t        this.counts.fill(0);\r\n\t    };\r\n\t    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + 1;\r\n\t        if (newCount < 0) {\r\n\t            throw newCount + \" would overflow short integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + value;\r\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n\t            newCount > Number.MAX_SAFE_INTEGER) {\r\n\t            throw newCount + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\r\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n\t            throw value + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = value;\r\n\t    };\r\n\t    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n\t        this.establishSize(newHighestTrackableValue);\r\n\t        var newCounts = new Uint32Array(this.countsArrayLength);\r\n\t        newCounts.set(this.counts);\r\n\t        this.counts = newCounts;\r\n\t    };\r\n\t    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n\t    Int32Histogram.prototype.incrementTotalCount = function () {\r\n\t        this.totalCount++;\r\n\t    };\r\n\t    Int32Histogram.prototype.addToTotalCount = function (value) {\r\n\t        this.totalCount += value;\r\n\t    };\r\n\t    Int32Histogram.prototype.setTotalCount = function (value) {\r\n\t        this.totalCount = value;\r\n\t    };\r\n\t    Int32Histogram.prototype.getTotalCount = function () {\r\n\t        return this.totalCount;\r\n\t    };\r\n\t    Int32Histogram.prototype.getCountAtIndex = function (index) {\r\n\t        return this.counts[index];\r\n\t    };\r\n\t    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n\t        return 512 + 4 * this.counts.length;\r\n\t    };\r\n\t    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n\t        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n\t        return copy;\r\n\t    };\r\n\t    return Int32Histogram;\r\n\t}(AbstractHistogram_1.default));\r\n\texports.default = Int32Histogram;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar ByteBuffer_1 = __webpack_require__(3);\r\n\tvar AbstractHistogram_1 = __webpack_require__(1);\r\n\tvar Int32Histogram_1 = __webpack_require__(4);\r\n\tvar base64 = __webpack_require__(9);\r\n\tvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\r\n\t    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\r\n\t    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\r\n\t    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String));\r\n\t    return AbstractHistogram_1.default.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\r\n\t};\r\n\texports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\r\n\tvar encodeIntoBase64String = function (histogram, compressionLevel) {\r\n\t    var buffer = ByteBuffer_1.default.allocate();\r\n\t    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\r\n\t    var encodedBuffer = buffer.data.slice(0, bufferSize);\r\n\t    return base64.fromByteArray(encodedBuffer);\r\n\t};\r\n\texports.encodeIntoBase64String = encodeIntoBase64String;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar HistogramIterationValue_1 = __webpack_require__(12);\r\n\t/**\r\n\t * Used for iterating through histogram values.\r\n\t */\r\n\tvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\r\n\t    function AbstractHistogramIterator() {\r\n\t        this.currentIterationValue = new HistogramIterationValue_1.default();\r\n\t    }\r\n\t    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\r\n\t        this.histogram = histogram;\r\n\t        this.savedHistogramTotalRawCount = histogram.getTotalCount();\r\n\t        this.arrayTotalCount = histogram.getTotalCount();\r\n\t        this.currentIndex = 0;\r\n\t        this.currentValueAtIndex = 0;\r\n\t        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\r\n\t        this.prevValueIteratedTo = 0;\r\n\t        this.totalCountToPrevIndex = 0;\r\n\t        this.totalCountToCurrentIndex = 0;\r\n\t        this.totalValueToCurrentIndex = 0;\r\n\t        this.countAtThisValue = 0;\r\n\t        this.freshSubBucket = true;\r\n\t        this.currentIterationValue.reset();\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\r\n\t     * element rather than throwing an exception.)\r\n\t     *\r\n\t     * @return true if the iterator has more elements.\r\n\t     */\r\n\t    AbstractHistogramIterator.prototype.hasNext = function () {\r\n\t        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\r\n\t            throw \"Concurrent Modification Exception\";\r\n\t        }\r\n\t        return this.totalCountToCurrentIndex < this.arrayTotalCount;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the next element in the iteration.\r\n\t     *\r\n\t     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\r\n\t     */\r\n\t    AbstractHistogramIterator.prototype.next = function () {\r\n\t        // Move through the sub buckets and buckets until we hit the next reporting level:\r\n\t        while (!this.exhaustedSubBuckets()) {\r\n\t            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\r\n\t            if (this.freshSubBucket) {\r\n\t                // Don't add unless we've incremented since last bucket...\r\n\t                this.totalCountToCurrentIndex += this.countAtThisValue;\r\n\t                this.totalValueToCurrentIndex +=\r\n\t                    this.countAtThisValue *\r\n\t                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\r\n\t                this.freshSubBucket = false;\r\n\t            }\r\n\t            if (this.reachedIterationLevel()) {\r\n\t                var valueIteratedTo = this.getValueIteratedTo();\r\n\t                Object.assign(this.currentIterationValue, {\r\n\t                    valueIteratedTo: valueIteratedTo,\r\n\t                    valueIteratedFrom: this.prevValueIteratedTo,\r\n\t                    countAtValueIteratedTo: this.countAtThisValue,\r\n\t                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\r\n\t                    totalCountToThisValue: this.totalCountToCurrentIndex,\r\n\t                    totalValueToThisValue: this.totalValueToCurrentIndex,\r\n\t                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\r\n\t                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\r\n\t                });\r\n\t                this.prevValueIteratedTo = valueIteratedTo;\r\n\t                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\r\n\t                this.incrementIterationLevel();\r\n\t                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\r\n\t                    throw \"Concurrent Modification Exception\";\r\n\t                }\r\n\t                return this.currentIterationValue;\r\n\t            }\r\n\t            this.incrementSubBucket();\r\n\t        }\r\n\t        throw \"Index Out Of Bounds Exception\";\r\n\t    };\r\n\t    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\r\n\t        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\r\n\t    };\r\n\t    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\r\n\t        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\r\n\t    };\r\n\t    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\r\n\t        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\r\n\t    };\r\n\t    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\r\n\t        return this.currentIndex >= this.histogram.countsArrayLength;\r\n\t    };\r\n\t    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\r\n\t        this.freshSubBucket = true;\r\n\t        this.currentIndex++;\r\n\t        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\r\n\t        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\r\n\t    };\r\n\t    return AbstractHistogramIterator;\r\n\t}());\r\n\texports.default = AbstractHistogramIterator;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar leftPadding = function (size) {\r\n\t    return function (input) {\r\n\t        if (input.length < size) {\r\n\t            return \" \".repeat(size - input.length) + input;\r\n\t        }\r\n\t        return input;\r\n\t    };\r\n\t};\r\n\texports.integerFormatter = function (size) {\r\n\t    var padding = leftPadding(size);\r\n\t    return function (integer) { return padding(\"\" + integer); };\r\n\t};\r\n\texports.floatFormatter = function (size, fractionDigits) {\r\n\t    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\r\n\t        maximumFractionDigits: fractionDigits,\r\n\t        minimumFractionDigits: fractionDigits,\r\n\t        useGrouping: false\r\n\t    });\r\n\t    var padding = leftPadding(size);\r\n\t    return function (float) { return padding(numberFormatter.format(float)); };\r\n\t};\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar EncodableHistogram = /** @class */ (function () {\r\n\t    function EncodableHistogram() {\r\n\t    }\r\n\t    return EncodableHistogram;\r\n\t}());\r\n\texports.EncodableHistogram = EncodableHistogram;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar AbstractHistogram_1 = __webpack_require__(1);\r\n\tvar Float64Histogram = /** @class */ (function (_super) {\r\n\t    __extends(Float64Histogram, _super);\r\n\t    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n\t        _this.totalCount = 0;\r\n\t        _this.counts = new Float64Array(_this.countsArrayLength);\r\n\t        return _this;\r\n\t    }\r\n\t    Float64Histogram.prototype.clearCounts = function () {\r\n\t        this.counts.fill(0);\r\n\t    };\r\n\t    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + 1;\r\n\t        if (newCount < 0) {\r\n\t            throw newCount + \" would overflow short integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + value;\r\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n\t            newCount > Number.MAX_SAFE_INTEGER) {\r\n\t            throw newCount + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\r\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n\t            throw value + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = value;\r\n\t    };\r\n\t    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n\t        this.establishSize(newHighestTrackableValue);\r\n\t        var newCounts = new Float64Array(this.countsArrayLength);\r\n\t        newCounts.set(this.counts);\r\n\t        this.counts = newCounts;\r\n\t    };\r\n\t    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n\t    Float64Histogram.prototype.incrementTotalCount = function () {\r\n\t        this.totalCount++;\r\n\t    };\r\n\t    Float64Histogram.prototype.addToTotalCount = function (value) {\r\n\t        this.totalCount += value;\r\n\t    };\r\n\t    Float64Histogram.prototype.setTotalCount = function (value) {\r\n\t        this.totalCount = value;\r\n\t    };\r\n\t    Float64Histogram.prototype.getTotalCount = function () {\r\n\t        return this.totalCount;\r\n\t    };\r\n\t    Float64Histogram.prototype.getCountAtIndex = function (index) {\r\n\t        return this.counts[index];\r\n\t    };\r\n\t    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n\t        return 512 + 8 * this.counts.length;\r\n\t    };\r\n\t    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n\t        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n\t        return copy;\r\n\t    };\r\n\t    return Float64Histogram;\r\n\t}(AbstractHistogram_1.default));\r\n\texports.default = Float64Histogram;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/**\r\n\t * Represents a value point iterated through in a Histogram, with associated stats.\r\n\t * <ul>\r\n\t * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\r\n\t * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\r\n\t * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\r\n\t * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\r\n\t * range.</li>\r\n\t * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\r\n\t * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\r\n\t * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\r\n\t * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\r\n\t * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\r\n\t * values equal or smaller than valueIteratedTo.</li>\r\n\t * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\r\n\t * equal or smaller than valueIteratedTo.</li>\r\n\t * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\r\n\t * or smaller than valueIteratedTo.</li>\r\n\t * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\r\n\t * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\r\n\t * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\r\n\t * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\r\n\t * range of multiple percentiles in the requested percentile iteration points).</li>\r\n\t * </ul>\r\n\t */\r\n\tvar HistogramIterationValue = /** @class */ (function () {\r\n\t    function HistogramIterationValue() {\r\n\t        this.reset();\r\n\t    }\r\n\t    HistogramIterationValue.prototype.reset = function () {\r\n\t        this.valueIteratedTo = 0;\r\n\t        this.valueIteratedFrom = 0;\r\n\t        this.countAtValueIteratedTo = 0;\r\n\t        this.countAddedInThisIterationStep = 0;\r\n\t        this.totalCountToThisValue = 0;\r\n\t        this.totalValueToThisValue = 0;\r\n\t        this.percentile = 0.0;\r\n\t        this.percentileLevelIteratedTo = 0.0;\r\n\t    };\r\n\t    return HistogramIterationValue;\r\n\t}());\r\n\texports.default = HistogramIterationValue;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar AbstractHistogramBase_1 = __webpack_require__(2);\r\n\tvar encoding_1 = __webpack_require__(5);\r\n\tvar TAG_PREFIX = \"Tag=\";\r\n\tvar TAG_PREFIX_LENGTH = \"Tag=\".length;\r\n\t/**\r\n\t * A histogram log reader.\r\n\t * <p>\r\n\t * Histogram logs are used to capture full fidelity, per-time-interval\r\n\t * histograms of a recorded value.\r\n\t * <p>\r\n\t * For example, a histogram log can be used to capture high fidelity\r\n\t * reaction-time logs for some measured system or subsystem component.\r\n\t * Such a log would capture a full reaction time histogram for each\r\n\t * logged interval, and could be used to later reconstruct a full\r\n\t * HdrHistogram of the measured reaction time behavior for any arbitrary\r\n\t * time range within the log, by adding [only] the relevant interval\r\n\t * histograms.\r\n\t * <h3>Histogram log format:</h3>\r\n\t * A histogram log file consists of text lines. Lines beginning with\r\n\t * the \"#\" character are optional and treated as comments. Lines\r\n\t * containing the legend (starting with \"Timestamp\") are also optional\r\n\t * and ignored in parsing the histogram log. All other lines must\r\n\t * be valid interval description lines. Text fields are delimited by\r\n\t * commas, spaces.\r\n\t * <p>\r\n\t * A valid interval description line contains an optional Tag=tagString\r\n\t * text field, followed by an interval description.\r\n\t * <p>\r\n\t * A valid interval description must contain exactly four text fields:\r\n\t * <ul>\r\n\t * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\r\n\t * representing the start timestamp of the interval in seconds.</li>\r\n\t * <li>intervalLength: The second field must contain a number parse-able as a Double value,\r\n\t * representing the length of the interval in seconds.</li>\r\n\t * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\r\n\t * which generally represents the maximum value of the interval histogram.</li>\r\n\t * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\r\n\t * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\r\n\t * </ul>\r\n\t * The log file may contain an optional indication of a starting time. Starting time\r\n\t * is indicated using a special comments starting with \"#[StartTime: \" and followed\r\n\t * by a number parse-able as a double, representing the start time (in seconds)\r\n\t * that may be added to timestamps in the file to determine an absolute\r\n\t * timestamp (e.g. since the epoch) for each interval.\r\n\t */\r\n\tvar HistogramLogReader = /** @class */ (function () {\r\n\t    function HistogramLogReader(logContent) {\r\n\t        this.lines = splitLines(logContent);\r\n\t        this.currentLineIndex = 0;\r\n\t    }\r\n\t    /**\r\n\t     * Read the next interval histogram from the log. Returns a Histogram object if\r\n\t     * an interval line was found, or null if not.\r\n\t     * <p>Upon encountering any unexpected format errors in reading the next interval\r\n\t     * from the file, this method will return a null.\r\n\t     * @return a DecodedInterval, or a null if no appropriate interval found\r\n\t     */\r\n\t    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\r\n\t        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\r\n\t        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\r\n\t        while (this.currentLineIndex < this.lines.length) {\r\n\t            var currentLine = this.lines[this.currentLineIndex];\r\n\t            this.currentLineIndex++;\r\n\t            if (currentLine.startsWith(\"#[StartTime:\")) {\r\n\t                this.parseStartTimeFromLine(currentLine);\r\n\t            }\r\n\t            else if (currentLine.startsWith(\"#[BaseTime:\")) {\r\n\t                this.parseBaseTimeFromLine(currentLine);\r\n\t            }\r\n\t            else if (currentLine.startsWith(\"#\") ||\r\n\t                currentLine.startsWith('\"StartTimestamp\"')) {\r\n\t                // skip legend & meta data for now\r\n\t            }\r\n\t            else if (currentLine.includes(\",\")) {\r\n\t                var tokens = currentLine.split(\",\");\r\n\t                var firstToken = tokens[0];\r\n\t                var tag = void 0;\r\n\t                if (firstToken.startsWith(TAG_PREFIX)) {\r\n\t                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\r\n\t                    tokens.shift();\r\n\t                }\r\n\t                else {\r\n\t                    tag = AbstractHistogramBase_1.NO_TAG;\r\n\t                }\r\n\t                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\r\n\t                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\r\n\t                if (!this.baseTimeSec) {\r\n\t                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\r\n\t                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\r\n\t                        // Criteria Note: if log timestamp is more than a year in the past (compared to\r\n\t                        // StartTime), we assume that timestamps in the log are not absolute\r\n\t                        this.baseTimeSec = this.startTimeSec;\r\n\t                    }\r\n\t                    else {\r\n\t                        // Timestamps are absolute\r\n\t                        this.baseTimeSec = 0.0;\r\n\t                    }\r\n\t                }\r\n\t                if (rangeEndTimeSec < logTimeStampInSec) {\r\n\t                    return null;\r\n\t                }\r\n\t                if (logTimeStampInSec < rangeStartTimeSec) {\r\n\t                    continue;\r\n\t                }\r\n\t                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram);\r\n\t                histogram.startTimeStampMsec =\r\n\t                    (this.baseTimeSec + logTimeStampInSec) * 1000;\r\n\t                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\r\n\t                histogram.endTimeStampMsec =\r\n\t                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\r\n\t                histogram.tag = tag;\r\n\t                return histogram;\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    };\r\n\t    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\r\n\t        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\r\n\t    };\r\n\t    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\r\n\t        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\r\n\t    };\r\n\t    return HistogramLogReader;\r\n\t}());\r\n\tvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\r\n\tvar shouldIncludeNoTag = function (lines) {\r\n\t    return lines.find(function (line) {\r\n\t        return !line.startsWith(\"#\") &&\r\n\t            !line.startsWith('\"') &&\r\n\t            !line.startsWith(TAG_PREFIX) &&\r\n\t            line.includes(\",\");\r\n\t    });\r\n\t};\r\n\texports.listTags = function (content) {\r\n\t    var lines = splitLines(content);\r\n\t    var tags = lines\r\n\t        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\r\n\t        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\r\n\t    var tagsWithoutDuplicates = new Set(tags);\r\n\t    var result = Array.from(tagsWithoutDuplicates);\r\n\t    if (shouldIncludeNoTag(lines)) {\r\n\t        result.unshift(\"NO TAG\");\r\n\t    }\r\n\t    return result;\r\n\t};\r\n\texports.default = HistogramLogReader;\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar AbstractHistogramBase_1 = __webpack_require__(2);\r\n\tvar encoding_1 = __webpack_require__(5);\r\n\tvar formatters_1 = __webpack_require__(7);\r\n\tvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\r\n\tvar timeFormatter = formatters_1.floatFormatter(5, 3);\r\n\tvar HistogramLogWriter = /** @class */ (function () {\r\n\t    function HistogramLogWriter(log) {\r\n\t        this.log = log;\r\n\t        /**\r\n\t           * Base time to subtract from supplied histogram start/end timestamps when\r\n\t           * logging based on histogram timestamps.\r\n\t           * Base time is expected to be in msec since the epoch, as histogram start/end times\r\n\t           * are typically stamped with absolute times in msec since the epoch.\r\n\t           */\r\n\t        this.baseTime = 0;\r\n\t    }\r\n\t    /**\r\n\t       * Output an interval histogram, with the given timestamp information and the [optional] tag\r\n\t       * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\r\n\t       * specified timestamp information will be used, and the timestamp information in the actual\r\n\t       * histogram will be ignored).\r\n\t       * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\r\n\t       * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\r\n\t       * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\r\n\t       * @param histogram The interval histogram to log.\r\n\t       * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\r\n\t       */\r\n\t    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\r\n\t        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\r\n\t        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\r\n\t        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\r\n\t        var base64 = encoding_1.encodeIntoBase64String(histogram);\r\n\t        var start = timeFormatter(startTimeStampSec);\r\n\t        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\r\n\t        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\r\n\t        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\r\n\t        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\r\n\t            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\r\n\t        }\r\n\t        else {\r\n\t            this.log(lineContent);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t       * Log a comment to the log.\r\n\t       * Comments will be preceded with with the '#' character.\r\n\t       * @param comment the comment string.\r\n\t       */\r\n\t    HistogramLogWriter.prototype.outputComment = function (comment) {\r\n\t        this.log(\"#\" + comment + \"\\n\");\r\n\t    };\r\n\t    /**\r\n\t       * Log a start time in the log.\r\n\t       * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\r\n\t       */\r\n\t    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\r\n\t        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\r\n\t    };\r\n\t    /**\r\n\t       * Output a legend line to the log.\r\n\t       */\r\n\t    HistogramLogWriter.prototype.outputLegend = function () {\r\n\t        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\r\n\t    };\r\n\t    /**\r\n\t       * Output a log format version to the log.\r\n\t       */\r\n\t    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\r\n\t        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\r\n\t    };\r\n\t    return HistogramLogWriter;\r\n\t}());\r\n\texports.default = HistogramLogWriter;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar AbstractHistogram_1 = __webpack_require__(1);\r\n\tvar Int16Histogram = /** @class */ (function (_super) {\r\n\t    __extends(Int16Histogram, _super);\r\n\t    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n\t        _this.totalCount = 0;\r\n\t        _this.counts = new Uint16Array(_this.countsArrayLength);\r\n\t        return _this;\r\n\t    }\r\n\t    Int16Histogram.prototype.clearCounts = function () {\r\n\t        this.counts.fill(0);\r\n\t    };\r\n\t    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + 1;\r\n\t        if (newCount < 0) {\r\n\t            throw newCount + \" would overflow short integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + value;\r\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n\t            newCount > Number.MAX_SAFE_INTEGER) {\r\n\t            throw newCount + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\r\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n\t            throw value + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = value;\r\n\t    };\r\n\t    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n\t        this.establishSize(newHighestTrackableValue);\r\n\t        var newCounts = new Uint16Array(this.countsArrayLength);\r\n\t        newCounts.set(this.counts);\r\n\t        this.counts = newCounts;\r\n\t    };\r\n\t    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n\t    Int16Histogram.prototype.incrementTotalCount = function () {\r\n\t        this.totalCount++;\r\n\t    };\r\n\t    Int16Histogram.prototype.addToTotalCount = function (value) {\r\n\t        this.totalCount += value;\r\n\t    };\r\n\t    Int16Histogram.prototype.setTotalCount = function (value) {\r\n\t        this.totalCount = value;\r\n\t    };\r\n\t    Int16Histogram.prototype.getTotalCount = function () {\r\n\t        return this.totalCount;\r\n\t    };\r\n\t    Int16Histogram.prototype.getCountAtIndex = function (index) {\r\n\t        return this.counts[index];\r\n\t    };\r\n\t    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n\t        return 512 + 2 * this.counts.length;\r\n\t    };\r\n\t    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n\t        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n\t        return copy;\r\n\t    };\r\n\t    return Int16Histogram;\r\n\t}(AbstractHistogram_1.default));\r\n\texports.default = Int16Histogram;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar AbstractHistogram_1 = __webpack_require__(1);\r\n\tvar Int8Histogram = /** @class */ (function (_super) {\r\n\t    __extends(Int8Histogram, _super);\r\n\t    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n\t        _this.totalCount = 0;\r\n\t        _this.counts = new Uint8Array(_this.countsArrayLength);\r\n\t        return _this;\r\n\t    }\r\n\t    Int8Histogram.prototype.clearCounts = function () {\r\n\t        this.counts.fill(0);\r\n\t    };\r\n\t    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + 1;\r\n\t        if (newCount < 0) {\r\n\t            throw newCount + \" would overflow short integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n\t        var currentCount = this.counts[index];\r\n\t        var newCount = currentCount + value;\r\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n\t            newCount > Number.MAX_SAFE_INTEGER) {\r\n\t            throw newCount + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = newCount;\r\n\t    };\r\n\t    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\r\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n\t            throw value + \" would overflow integer count\";\r\n\t        }\r\n\t        this.counts[index] = value;\r\n\t    };\r\n\t    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n\t        this.establishSize(newHighestTrackableValue);\r\n\t        var newCounts = new Uint8Array(this.countsArrayLength);\r\n\t        newCounts.set(this.counts);\r\n\t        this.counts = newCounts;\r\n\t    };\r\n\t    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n\t    Int8Histogram.prototype.incrementTotalCount = function () {\r\n\t        this.totalCount++;\r\n\t    };\r\n\t    Int8Histogram.prototype.addToTotalCount = function (value) {\r\n\t        this.totalCount += value;\r\n\t    };\r\n\t    Int8Histogram.prototype.setTotalCount = function (value) {\r\n\t        this.totalCount = value;\r\n\t    };\r\n\t    Int8Histogram.prototype.getTotalCount = function () {\r\n\t        return this.totalCount;\r\n\t    };\r\n\t    Int8Histogram.prototype.getCountAtIndex = function (index) {\r\n\t        return this.counts[index];\r\n\t    };\r\n\t    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n\t        return 512 + this.counts.length;\r\n\t    };\r\n\t    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n\t        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n\t        return copy;\r\n\t    };\r\n\t    return Int8Histogram;\r\n\t}(AbstractHistogram_1.default));\r\n\texports.default = Int8Histogram;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar AbstractHistogramIterator_1 = __webpack_require__(6);\r\n\tvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\r\n\t/**\r\n\t * Used for iterating through histogram values according to percentile levels. The iteration is\r\n\t * performed in steps that start at 0% and reduce their distance to 100% according to the\r\n\t * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\r\n\t * values are exhausted.\r\n\t */\r\n\tvar PercentileIterator = /** @class */ (function (_super) {\r\n\t    __extends(PercentileIterator, _super);\r\n\t    /**\r\n\t       * @param histogram The histogram this iterator will operate on\r\n\t       * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\r\n\t       */\r\n\t    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\r\n\t        var _this = _super.call(this) || this;\r\n\t        _this.percentileTicksPerHalfDistance = 0;\r\n\t        _this.percentileLevelToIterateTo = 0;\r\n\t        _this.percentileLevelToIterateFrom = 0;\r\n\t        _this.reachedLastRecordedValue = false;\r\n\t        _this.doReset(histogram, percentileTicksPerHalfDistance);\r\n\t        return _this;\r\n\t    }\r\n\t    /**\r\n\t       * Reset iterator for re-use in a fresh iteration over the same histogram data set.\r\n\t       *\r\n\t       * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\r\n\t       */\r\n\t    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\r\n\t        this.doReset(this.histogram, percentileTicksPerHalfDistance);\r\n\t    };\r\n\t    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\r\n\t        _super.prototype.resetIterator.call(this, histogram);\r\n\t        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\r\n\t        this.percentileLevelToIterateTo = 0;\r\n\t        this.percentileLevelToIterateFrom = 0;\r\n\t        this.reachedLastRecordedValue = false;\r\n\t    };\r\n\t    PercentileIterator.prototype.hasNext = function () {\r\n\t        if (_super.prototype.hasNext.call(this))\r\n\t            return true;\r\n\t        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\r\n\t            this.percentileLevelToIterateTo = 100;\r\n\t            this.reachedLastRecordedValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    PercentileIterator.prototype.incrementIterationLevel = function () {\r\n\t        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\r\n\t        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\r\n\t        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\r\n\t        // make the steps easily comprehensible and readable to humans. The resulting percentile\r\n\t        // steps are much easier to browse through in a percentile distribution output, for example.\r\n\t        //\r\n\t        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\r\n\t        // by at the current scale. The scale is detemined by the percentile level we are\r\n\t        // iterating to. The following math determines the tick size for the current scale,\r\n\t        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\r\n\t        // [from either 0% or from the previous half-distance]. When that half-distance is\r\n\t        // crossed, the scale changes and the tick size is effectively cut in half.\r\n\t        // percentileTicksPerHalfDistance = 5\r\n\t        // percentileReportingTicks = 10,\r\n\t        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\r\n\t            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\r\n\t        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\r\n\t    };\r\n\t    PercentileIterator.prototype.reachedIterationLevel = function () {\r\n\t        if (this.countAtThisValue === 0) {\r\n\t            return false;\r\n\t        }\r\n\t        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\r\n\t        return currentPercentile >= this.percentileLevelToIterateTo;\r\n\t    };\r\n\t    PercentileIterator.prototype.getPercentileIteratedTo = function () {\r\n\t        return this.percentileLevelToIterateTo;\r\n\t    };\r\n\t    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\r\n\t        return this.percentileLevelToIterateFrom;\r\n\t    };\r\n\t    return PercentileIterator;\r\n\t}(AbstractHistogramIterator_1.default));\r\n\texports.default = PercentileIterator;\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar __extends = (this && this.__extends) || (function () {\r\n\t    var extendStatics = Object.setPrototypeOf ||\r\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t    return function (d, b) {\r\n\t        extendStatics(d, b);\r\n\t        function __() { this.constructor = d; }\r\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t    };\r\n\t})();\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar AbstractHistogramIterator_1 = __webpack_require__(6);\r\n\t/**\r\n\t * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\r\n\t * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\r\n\t * all recorded histogram values are exhausted.\r\n\t */\r\n\tvar RecordedValuesIterator = /** @class */ (function (_super) {\r\n\t    __extends(RecordedValuesIterator, _super);\r\n\t    /**\r\n\t     * @param histogram The histogram this iterator will operate on\r\n\t     */\r\n\t    function RecordedValuesIterator(histogram) {\r\n\t        var _this = _super.call(this) || this;\r\n\t        _this.doReset(histogram);\r\n\t        return _this;\r\n\t    }\r\n\t    /**\r\n\t     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\r\n\t     */\r\n\t    RecordedValuesIterator.prototype.reset = function () {\r\n\t        this.doReset(this.histogram);\r\n\t    };\r\n\t    RecordedValuesIterator.prototype.doReset = function (histogram) {\r\n\t        _super.prototype.resetIterator.call(this, histogram);\r\n\t        this.visitedIndex = -1;\r\n\t    };\r\n\t    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\r\n\t        this.visitedIndex = this.currentIndex;\r\n\t    };\r\n\t    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\r\n\t        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\r\n\t        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\r\n\t    };\r\n\t    return RecordedValuesIterator;\r\n\t}(AbstractHistogramIterator_1.default));\r\n\texports.default = RecordedValuesIterator;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar Int32Histogram_1 = __webpack_require__(4);\r\n\t/**\r\n\t * Records integer values, and provides stable interval {@link Histogram} samples from\r\n\t * live recorded data without interrupting or stalling active recording of values. Each interval\r\n\t * histogram provided contains all value counts accumulated since the previous interval histogram\r\n\t * was taken.\r\n\t * <p>\r\n\t * This pattern is commonly used in logging interval histogram information while recording is ongoing.\r\n\t * <p>\r\n\t * {@link Recorder} supports concurrent\r\n\t * {@link Recorder#recordValue} or\r\n\t * {@link Recorder#recordValueWithExpectedInterval} calls.\r\n\t *\r\n\t */\r\n\tvar Recorder = /** @class */ (function () {\r\n\t    /**\r\n\t     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\r\n\t     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\r\n\t     *\r\n\t     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\r\n\t     *                                       decimal digits to which the histogram will maintain value resolution\r\n\t     *                                       and separation. Must be a non-negative integer between 0 and 5.\r\n\t     * @param clock (for testing purpose) an action that give current time in ms since 1970\r\n\t     */\r\n\t    function Recorder(numberOfSignificantValueDigits, clock) {\r\n\t        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\r\n\t        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\r\n\t        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\r\n\t        this.clock = clock;\r\n\t        this.activeHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\r\n\t        Recorder.idGenerator++;\r\n\t        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\r\n\t        this.activeHistogram.startTimeStampMsec = clock();\r\n\t    }\r\n\t    /**\r\n\t     * Record a value in the histogram\r\n\t     *\r\n\t     * @param value The value to be recorded\r\n\t     * @throws may throw Error if value is exceeds highestTrackableValue\r\n\t     */\r\n\t    Recorder.prototype.recordValue = function (value) {\r\n\t        this.activeHistogram.recordValue(value);\r\n\t    };\r\n\t    /**\r\n\t     * Record a value in the histogram (adding to the value's current count)\r\n\t     *\r\n\t     * @param value The value to be recorded\r\n\t     * @param count The number of occurrences of this value to record\r\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n\t     */\r\n\t    Recorder.prototype.recordValueWithCount = function (value, count) {\r\n\t        this.activeHistogram.recordValueWithCount(value, count);\r\n\t    };\r\n\t    /**\r\n\t     * Record a value\r\n\t     * <p>\r\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n\t     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\r\n\t     * (down to the expectedIntervalBetweenValueSamples) value records.\r\n\t     * <p>\r\n\t     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\r\n\t     * for more explanations about coordinated omission and expected interval correction.\r\n\t     *      *\r\n\t     * @param value The value to record\r\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n\t     *                                           auto-generated value records as appropriate if value is larger\r\n\t     *                                           than expectedIntervalBetweenValueSamples\r\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n\t     */\r\n\t    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n\t        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\r\n\t    };\r\n\t    /**\r\n\t     * Get an interval histogram, which will include a stable, consistent view of all value counts\r\n\t     * accumulated since the last interval histogram was taken.\r\n\t     * <p>\r\n\t     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n\t     * getIntervalHistogram(histogramToRecycle)}\r\n\t     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\r\n\t     * and content copying operations, and is therefore significantly more efficient for repeated use than\r\n\t     * {@link Recorder#getIntervalHistogram()} and\r\n\t     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\r\n\t     * {@code histogramToRecycle} must\r\n\t     * be either be null or an interval histogram returned by a previous call to\r\n\t     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n\t     * getIntervalHistogram(histogramToRecycle)} or\r\n\t     * {@link Recorder#getIntervalHistogram()}.\r\n\t     * <p>\r\n\t     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\r\n\t     * the same interval histogram instance is recycled more than once, behavior is undefined.\r\n\t     * <p>\r\n\t     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n\t     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\r\n\t     * counts for the next interval\r\n\t     *\r\n\t     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\r\n\t     *                           copy operations.\r\n\t     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\r\n\t     */\r\n\t    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\r\n\t        if (histogramToRecycle) {\r\n\t            var histogramToRecycleWithId = histogramToRecycle;\r\n\t            if (histogramToRecycleWithId.containingInstanceId !==\r\n\t                this.activeHistogram.containingInstanceId) {\r\n\t                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\r\n\t            }\r\n\t        }\r\n\t        this.inactiveHistogram = histogramToRecycle;\r\n\t        this.performIntervalSample();\r\n\t        var sampledHistogram = this.inactiveHistogram;\r\n\t        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\r\n\t        return sampledHistogram;\r\n\t    };\r\n\t    /**\r\n\t     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\r\n\t     * was taken) into {@code targetHistogram}.\r\n\t     *\r\n\t     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\r\n\t     * the value counts, and start accumulating value counts for the next interval.\r\n\t     *\r\n\t     * @param targetHistogram the histogram into which the interval histogram's data should be copied\r\n\t     */\r\n\t    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\r\n\t        this.performIntervalSample();\r\n\t        if (this.inactiveHistogram) {\r\n\t            targetHistogram.add(this.inactiveHistogram);\r\n\t            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\r\n\t            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Reset any value counts accumulated thus far.\r\n\t     */\r\n\t    Recorder.prototype.reset = function () {\r\n\t        this.activeHistogram.reset();\r\n\t        this.activeHistogram.startTimeStampMsec = this.clock();\r\n\t    };\r\n\t    Recorder.prototype.performIntervalSample = function () {\r\n\t        if (!this.inactiveHistogram) {\r\n\t            this.inactiveHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\r\n\t            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\r\n\t        }\r\n\t        this.inactiveHistogram.reset();\r\n\t        var tempHistogram = this.activeHistogram;\r\n\t        this.activeHistogram = this.inactiveHistogram;\r\n\t        this.inactiveHistogram = tempHistogram;\r\n\t        var currentTimeInMs = this.clock();\r\n\t        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\r\n\t        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\r\n\t    };\r\n\t    Recorder.idGenerator = 0;\r\n\t    return Recorder;\r\n\t}());\r\n\texports.default = Recorder;\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar pow = Math.pow, floor = Math.floor;\r\n\tvar TWO_POW_7 = pow(2, 7);\r\n\tvar TWO_POW_14 = pow(2, 14);\r\n\tvar TWO_POW_21 = pow(2, 21);\r\n\tvar TWO_POW_28 = pow(2, 28);\r\n\tvar TWO_POW_35 = pow(2, 35);\r\n\tvar TWO_POW_42 = pow(2, 42);\r\n\tvar TWO_POW_49 = pow(2, 49);\r\n\tvar TWO_POW_56 = pow(2, 56);\r\n\t/**\r\n\t * This class provides encoding and decoding methods for writing and reading\r\n\t * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\r\n\t * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\r\n\t * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\r\n\t * allows small (closer to zero) negative values to use fewer bytes. Details\r\n\t * on both LEB128 and ZigZag can be readily found elsewhere.\r\n\t *\r\n\t * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\r\n\t * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\r\n\t * value can take up to 10 bytes in the stream, where this variant's encoding\r\n\t * of a 64 bit values will max out at 9 bytes.\r\n\t *\r\n\t * As such, this encoder/decoder should NOT be used for encoding or decoding\r\n\t * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\r\n\t */\r\n\tvar ZigZagEncoding = /** @class */ (function () {\r\n\t    function ZigZagEncoding() {\r\n\t    }\r\n\t    /**\r\n\t     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\r\n\t     * (negative numbers not supported)\r\n\t     * @param buffer the buffer to write to\r\n\t     * @param value  the value to write to the buffer\r\n\t     */\r\n\t    ZigZagEncoding.encode = function (buffer, value) {\r\n\t        if (value >= 0) {\r\n\t            value = value * 2;\r\n\t        }\r\n\t        else {\r\n\t            value = -value * 2 - 1;\r\n\t        }\r\n\t        if (value < TWO_POW_7) {\r\n\t            buffer.put(value);\r\n\t        }\r\n\t        else {\r\n\t            buffer.put(value % 0x80 + 0x80);\r\n\t            if (value < TWO_POW_14) {\r\n\t                buffer.put(floor(value / TWO_POW_7));\r\n\t            }\r\n\t            else {\r\n\t                buffer.put(floor(value / TWO_POW_7) + 0x80);\r\n\t                if (value < TWO_POW_21) {\r\n\t                    buffer.put(floor(value / TWO_POW_14));\r\n\t                }\r\n\t                else {\r\n\t                    buffer.put(floor(value / TWO_POW_14) + 0x80);\r\n\t                    if (value < TWO_POW_28) {\r\n\t                        buffer.put(floor(value / TWO_POW_21));\r\n\t                    }\r\n\t                    else {\r\n\t                        buffer.put(floor(value / TWO_POW_21) + 0x80);\r\n\t                        if (value < TWO_POW_35) {\r\n\t                            buffer.put(floor(value / TWO_POW_28));\r\n\t                        }\r\n\t                        else {\r\n\t                            buffer.put(floor(value / TWO_POW_28) + 0x80);\r\n\t                            if (value < TWO_POW_42) {\r\n\t                                buffer.put(floor(value / TWO_POW_35));\r\n\t                            }\r\n\t                            else {\r\n\t                                buffer.put(floor(value / TWO_POW_35) + 0x80);\r\n\t                                if (value < TWO_POW_49) {\r\n\t                                    buffer.put(floor(value / TWO_POW_42));\r\n\t                                }\r\n\t                                else {\r\n\t                                    buffer.put(floor(value / TWO_POW_42) + 0x80);\r\n\t                                    if (value < TWO_POW_56) {\r\n\t                                        buffer.put(floor(value / TWO_POW_49));\r\n\t                                    }\r\n\t                                    else {\r\n\t                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\r\n\t                                        buffer.put(floor(value / TWO_POW_56));\r\n\t                                    }\r\n\t                                }\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\r\n\t     * (negative numbers not supported)\r\n\t     * @param buffer the buffer to read from\r\n\t     * @return the value read from the buffer\r\n\t     */\r\n\t    ZigZagEncoding.decode = function (buffer) {\r\n\t        var v = buffer.get();\r\n\t        var value = v & 0x7f;\r\n\t        if ((v & 0x80) != 0) {\r\n\t            v = buffer.get();\r\n\t            value += (v & 0x7f) * TWO_POW_7;\r\n\t            if ((v & 0x80) != 0) {\r\n\t                v = buffer.get();\r\n\t                value += (v & 0x7f) * TWO_POW_14;\r\n\t                if ((v & 0x80) != 0) {\r\n\t                    v = buffer.get();\r\n\t                    value += (v & 0x7f) * TWO_POW_21;\r\n\t                    if ((v & 0x80) != 0) {\r\n\t                        v = buffer.get();\r\n\t                        value += (v & 0x7f) * TWO_POW_28;\r\n\t                        if ((v & 0x80) != 0) {\r\n\t                            v = buffer.get();\r\n\t                            value += (v & 0x7f) * TWO_POW_35;\r\n\t                            if ((v & 0x80) != 0) {\r\n\t                                v = buffer.get();\r\n\t                                value += (v & 0x7f) * TWO_POW_42;\r\n\t                                if ((v & 0x80) != 0) {\r\n\t                                    v = buffer.get();\r\n\t                                    value += (v & 0x7f) * TWO_POW_49;\r\n\t                                    if ((v & 0x80) != 0) {\r\n\t                                        v = buffer.get();\r\n\t                                        value += (v & 0x7f) * TWO_POW_56;\r\n\t                                    }\r\n\t                                }\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if (value % 2 === 0) {\r\n\t            value = value / 2;\r\n\t        }\r\n\t        else {\r\n\t            value = -(value + 1) / 2;\r\n\t        }\r\n\t        return value;\r\n\t    };\r\n\t    return ZigZagEncoding;\r\n\t}());\r\n\texports.default = ZigZagEncoding;\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tvar ByteBuffer_1 = __webpack_require__(3);\r\n\texports.ByteBuffer = ByteBuffer_1.default;\r\n\tvar Int8Histogram_1 = __webpack_require__(16);\r\n\texports.Int8Histogram = Int8Histogram_1.default;\r\n\tvar Int16Histogram_1 = __webpack_require__(15);\r\n\texports.Int16Histogram = Int16Histogram_1.default;\r\n\tvar Int32Histogram_1 = __webpack_require__(4);\r\n\texports.Int32Histogram = Int32Histogram_1.default;\r\n\tvar Float64Histogram_1 = __webpack_require__(11);\r\n\texports.Float64Histogram = Float64Histogram_1.default;\r\n\tvar AbstractHistogram_1 = __webpack_require__(1);\r\n\texports.AbstractHistogram = AbstractHistogram_1.default;\r\n\texports.Histogram = AbstractHistogram_1.default;\r\n\tvar HistogramLogReader_1 = __webpack_require__(13);\r\n\texports.HistogramLogReader = HistogramLogReader_1.default;\r\n\texports.listTags = HistogramLogReader_1.listTags;\r\n\tvar HistogramLogWriter_1 = __webpack_require__(14);\r\n\texports.HistogramLogWriter = HistogramLogWriter_1.default;\r\n\tvar encoding_1 = __webpack_require__(5);\r\n\texports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\r\n\texports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\r\n\tvar Recorder_1 = __webpack_require__(19);\r\n\texports.Recorder = Recorder_1.default;\r\n\tvar defaultRequest = {\r\n\t    bitBucketSize: 32,\r\n\t    autoResize: true,\r\n\t    lowestDiscernibleValue: 1,\r\n\t    highestTrackableValue: 2,\r\n\t    numberOfSignificantValueDigits: 3\r\n\t};\r\n\texports.defaultRequest = defaultRequest;\r\n\tvar build = function (request) {\r\n\t    if (request === void 0) { request = defaultRequest; }\r\n\t    var parameters = Object.assign({}, defaultRequest, request);\r\n\t    var histogramConstr;\r\n\t    switch (parameters.bitBucketSize) {\r\n\t        case 8:\r\n\t            histogramConstr = Int8Histogram_1.default;\r\n\t            break;\r\n\t        case 16:\r\n\t            histogramConstr = Int16Histogram_1.default;\r\n\t            break;\r\n\t        case 32:\r\n\t            histogramConstr = Int32Histogram_1.default;\r\n\t            break;\r\n\t        default:\r\n\t            histogramConstr = Float64Histogram_1.default;\r\n\t    }\r\n\t    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\r\n\t    histogram.autoResize = parameters.autoResize;\r\n\t    return histogram;\r\n\t};\r\n\texports.build = build;\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\r\n\t/*\r\n\t * This is a TypeScript port of the original Java version, which was written by\r\n\t * Gil Tene as described in\r\n\t * https://github.com/HdrHistogram/HdrHistogram\r\n\t * and released to the public domain, as explained at\r\n\t * http://creativecommons.org/publicdomain/zero/1.0/\r\n\t */\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\r\n\texports.default = ulp;\r\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// hdrhistogram.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 615e0f034f75e390c604","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\r\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\r\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\r\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\r\nvar formatters_1 = require(\"./formatters\");\r\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\r\nvar ulp_1 = require(\"./ulp\");\r\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\r\nvar V2EncodingCookieBase = 0x1c849303;\r\nvar V2CompressedEncodingCookieBase = 0x1c849304;\r\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\r\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\r\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\r\nvar AbstractHistogram = /** @class */ (function (_super) {\r\n    __extends(AbstractHistogram, _super);\r\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this) || this;\r\n        _this.maxValue = 0;\r\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\r\n        // Verify argument validity\r\n        if (lowestDiscernibleValue < 1) {\r\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\r\n        }\r\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\r\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue\");\r\n        }\r\n        if (numberOfSignificantValueDigits < 0 ||\r\n            numberOfSignificantValueDigits > 5) {\r\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\r\n        }\r\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\r\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\r\n        return _this;\r\n    }\r\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\r\n        var internalValue = value + this.unitMagnitudeMask;\r\n        this.maxValue = internalValue;\r\n    };\r\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\r\n        if (value <= this.unitMagnitudeMask) {\r\n            return;\r\n        }\r\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\r\n            this.lowestDiscernibleValueRounded;\r\n        this.minNonZeroValue = internalValue;\r\n    };\r\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\r\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\r\n            this.lowestDiscernibleValueRounded;\r\n        this.minNonZeroValue =\r\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\r\n                ? minNonZeroValue\r\n                : internalValue;\r\n    };\r\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\r\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\r\n        this.highestTrackableValue = highestTrackableValue;\r\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\r\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\r\n        if (normalizingIndexOffset !== 0) {\r\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\r\n        }\r\n        /*\r\n        * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\r\n        * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\r\n        * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\r\n        */\r\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\r\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\r\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\r\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\r\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\r\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\r\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\r\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\r\n        this.subBucketHalfCountMagnitude =\r\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\r\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\r\n        this.subBucketHalfCount = this.subBucketCount / 2;\r\n        this.subBucketMask =\r\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\r\n        this.establishSize(highestTrackableValue);\r\n        this.leadingZeroCountBase =\r\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\r\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\r\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\r\n    };\r\n    /**\r\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\r\n     *\r\n     * <pre>\r\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\r\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\r\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\r\n     * ...\r\n     * </pre>\r\n     *\r\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\r\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\r\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\r\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\r\n     * values as it has better precision.\r\n     */\r\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\r\n        // establish counts array length:\r\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\r\n        // establish exponent range needed to support the trackable value with no overflow:\r\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\r\n        // establish the new highest trackable value:\r\n        this.highestTrackableValue = newHighestTrackableValue;\r\n    };\r\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\r\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\r\n            throw new Error(\"highestTrackableValue (\" +\r\n                highestTrackableValue +\r\n                \") cannot be < (2 * lowestDiscernibleValue)\");\r\n        }\r\n        //determine counts array length needed:\r\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\r\n        return countsArrayLength;\r\n    };\r\n    /**\r\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\r\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\r\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\r\n     * value if we consider the sub-bucket length to be halved.\r\n     */\r\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\r\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\r\n        return lengthNeeded;\r\n    };\r\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\r\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\r\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\r\n        // always have at least 1 bucket\r\n        var bucketsNeeded = 1;\r\n        while (smallestUntrackableValue <= value) {\r\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\r\n                // TODO check array max size in JavaScript\r\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\r\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\r\n                return bucketsNeeded + 1;\r\n            }\r\n            smallestUntrackableValue = smallestUntrackableValue * 2;\r\n            bucketsNeeded++;\r\n        }\r\n        return bucketsNeeded;\r\n    };\r\n    /**\r\n     * Record a value in the histogram\r\n     *\r\n     * @param value The value to be recorded\r\n     * @throws may throw Error if value is exceeds highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.recordValue = function (value) {\r\n        this.recordSingleValue(value);\r\n    };\r\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\r\n        var countsIndex = this.countsArrayIndex(value);\r\n        if (countsIndex >= this.countsArrayLength) {\r\n            this.handleRecordException(1, value);\r\n        }\r\n        else {\r\n            this.incrementCountAtIndex(countsIndex);\r\n        }\r\n        this.updateMinAndMax(value);\r\n        this.incrementTotalCount();\r\n    };\r\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\r\n        if (!this.autoResize) {\r\n            throw \"Value \" + value + \" is outside of histogram covered range\";\r\n        }\r\n        this.resize(value);\r\n        var countsIndex = this.countsArrayIndex(value);\r\n        this.addToCountAtIndex(countsIndex, count);\r\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\r\n    };\r\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\r\n        if (value < 0) {\r\n            throw new Error(\"Histogram recorded value cannot be negative.\");\r\n        }\r\n        var bucketIndex = this.getBucketIndex(value);\r\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\r\n    };\r\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\r\n        // TODO\r\n        //assert(subBucketIndex < subBucketCount);\r\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\r\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\r\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\r\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\r\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\r\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\r\n        // However, this works out since we give bucket 0 twice as much space.\r\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\r\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\r\n        return bucketBaseIndex + offsetInBucket;\r\n    };\r\n    /**\r\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\r\n     */\r\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\r\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\r\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\r\n        // The mask maps small values to bucket 0.\r\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\r\n        return max(floor(log2(value)) -\r\n            this.subBucketHalfCountMagnitude -\r\n            this.unitMagnitude, 0);\r\n    };\r\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\r\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\r\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\r\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\r\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\r\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\r\n        // and therefore in the top half of subBucketCount.\r\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\r\n    };\r\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\r\n        if (value > this.maxValue) {\r\n            this.updatedMaxValue(value);\r\n        }\r\n        if (value < this.minNonZeroValue && value !== 0) {\r\n            this.updateMinNonZeroValue(value);\r\n        }\r\n    };\r\n    /**\r\n     * Get the value at a given percentile.\r\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\r\n     * percentage of the overall recorded value entries in the histogram are either smaller than\r\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\r\n     * entries in the histogram are either larger than or equivalent to.\r\n     * <p>\r\n     * Note that two values are \"equivalent\" in this statement if\r\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\r\n     *\r\n     * @param percentile  The percentile for which to return the associated value\r\n     * @return The value that the given percentage of the overall recorded value entries in the\r\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\r\n     * value that all value entries in the histogram are either larger than or equivalent to.\r\n     */\r\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\r\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\r\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\r\n        // of overall recorded values is actually included. However, this must be done with care:\r\n        //\r\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\r\n        // being 1 ulp larger than the correct integer count for this percentile:\r\n        var fpCountAtPercentile = requestedPercentile / 100.0 * this.getTotalCount();\r\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\r\n        // making us skip a count:\r\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\r\n        1 // Make sure we at least reach the first recorded entry\r\n        );\r\n        var totalToCurrentIndex = 0;\r\n        for (var i = 0; i < this.countsArrayLength; i++) {\r\n            totalToCurrentIndex += this.getCountAtIndex(i);\r\n            if (totalToCurrentIndex >= countAtPercentile) {\r\n                var valueAtIndex = this.valueFromIndex(i);\r\n                return percentile === 0.0\r\n                    ? this.lowestEquivalentValue(valueAtIndex)\r\n                    : this.highestEquivalentValue(valueAtIndex);\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\r\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\r\n    };\r\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\r\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\r\n        var subBucketIndex = index % this.subBucketHalfCount + this.subBucketHalfCount;\r\n        if (bucketIndex < 0) {\r\n            subBucketIndex -= this.subBucketHalfCount;\r\n            bucketIndex = 0;\r\n        }\r\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\r\n    };\r\n    /**\r\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\r\n     */\r\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\r\n        var bucketIndex = this.getBucketIndex(value);\r\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\r\n        return thisValueBaseLevel;\r\n    };\r\n    /**\r\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\r\n     */\r\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\r\n        return this.nextNonEquivalentValue(value) - 1;\r\n    };\r\n    /**\r\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\r\n     */\r\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\r\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\r\n    };\r\n    /**\r\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\r\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The size of the range of values equivalent to the given value.\r\n     */\r\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\r\n        var bucketIndex = this.getBucketIndex(value);\r\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n        var distanceToNextValue = pow(2, this.unitMagnitude +\r\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\r\n        return distanceToNextValue;\r\n    };\r\n    /**\r\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\r\n     */\r\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\r\n        return (this.lowestEquivalentValue(value) +\r\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\r\n    };\r\n    /**\r\n     * Get the computed mean value of all recorded values in the histogram\r\n     *\r\n     * @return the mean value (in value units) of the histogram data\r\n     */\r\n    AbstractHistogram.prototype.getMean = function () {\r\n        if (this.getTotalCount() === 0) {\r\n            return 0;\r\n        }\r\n        this.recordedValuesIterator.reset();\r\n        var totalValue = 0;\r\n        while (this.recordedValuesIterator.hasNext()) {\r\n            var iterationValue = this.recordedValuesIterator.next();\r\n            totalValue +=\r\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\r\n                    iterationValue.countAtValueIteratedTo;\r\n        }\r\n        return totalValue * 1.0 / this.getTotalCount();\r\n    };\r\n    /**\r\n     * Get the computed standard deviation of all recorded values in the histogram\r\n     *\r\n     * @return the standard deviation (in value units) of the histogram data\r\n     */\r\n    AbstractHistogram.prototype.getStdDeviation = function () {\r\n        if (this.getTotalCount() === 0) {\r\n            return 0;\r\n        }\r\n        var mean = this.getMean();\r\n        var geometric_deviation_total = 0.0;\r\n        this.recordedValuesIterator.reset();\r\n        while (this.recordedValuesIterator.hasNext()) {\r\n            var iterationValue = this.recordedValuesIterator.next();\r\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\r\n            geometric_deviation_total +=\r\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\r\n        }\r\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\r\n        return std_deviation;\r\n    };\r\n    /**\r\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\r\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\r\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\r\n     *\r\n     * @param printStream    Stream into which the distribution will be output\r\n     * <p>\r\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\r\n     * <p>\r\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\r\n     *                                     output\r\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\r\n     */\r\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\r\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\r\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\r\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\r\n        var result = \"\";\r\n        if (useCsvFormat) {\r\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\r\n        }\r\n        else {\r\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\r\n        }\r\n        var iterator = this.percentileIterator;\r\n        iterator.reset(percentileTicksPerHalfDistance);\r\n        var lineFormatter;\r\n        var lastLineFormatter;\r\n        if (useCsvFormat) {\r\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\r\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\r\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\r\n            lineFormatter = function (iterationValue) {\r\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \",\" +\r\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \",\" +\r\n                    iterationValue.totalCountToThisValue +\r\n                    \",\" +\r\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\r\n                    \"\\n\";\r\n            };\r\n            lastLineFormatter = function (iterationValue) {\r\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \",\" +\r\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \",\" +\r\n                    iterationValue.totalCountToThisValue +\r\n                    \",Infinity\\n\";\r\n            };\r\n        }\r\n        else {\r\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\r\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\r\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\r\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\r\n            lineFormatter = function (iterationValue) {\r\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \" \" +\r\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \" \" +\r\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\r\n                    \" \" +\r\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\r\n                    \"\\n\";\r\n            };\r\n            lastLineFormatter = function (iterationValue) {\r\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \" \" +\r\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \" \" +\r\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\r\n                    \"\\n\";\r\n            };\r\n        }\r\n        while (iterator.hasNext()) {\r\n            var iterationValue = iterator.next();\r\n            if (iterationValue.percentileLevelIteratedTo < 100) {\r\n                result += lineFormatter(iterationValue);\r\n            }\r\n            else {\r\n                result += lastLineFormatter(iterationValue);\r\n            }\r\n        }\r\n        if (!useCsvFormat) {\r\n            // Calculate and output mean and std. deviation.\r\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\r\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\r\n            // response time distribution associated with GC pauses). However, reporting these numbers\r\n            // can be very useful for contrasting with the detailed percentile distribution\r\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\r\n            // percentile distributions where results fall many tens or even hundreds of standard\r\n            // deviations away from the mean - such results simply indicate that the data sampled\r\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\r\n            // deviation metric is a useless indicator.\r\n            //\r\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\r\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\r\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\r\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\r\n            var intFormatter = formatters_1.integerFormatter(12);\r\n            var totalCount = intFormatter(this.getTotalCount());\r\n            var bucketCount = intFormatter(this.bucketCount);\r\n            var subBucketCount = intFormatter(this.subBucketCount);\r\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\r\n     *\r\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\r\n     */\r\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\r\n        return this._getEstimatedFootprintInBytes();\r\n    };\r\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n        this.recordSingleValue(value);\r\n        if (expectedIntervalBetweenValueSamples <= 0) {\r\n            return;\r\n        }\r\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\r\n            this.recordSingleValue(missingValue);\r\n        }\r\n    };\r\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\r\n        var countsIndex = this.countsArrayIndex(value);\r\n        if (countsIndex >= this.countsArrayLength) {\r\n            this.handleRecordException(count, value);\r\n        }\r\n        else {\r\n            this.addToCountAtIndex(countsIndex, count);\r\n        }\r\n        this.updateMinAndMax(value);\r\n        this.addToTotalCount(count);\r\n    };\r\n    /**\r\n     * Record a value in the histogram (adding to the value's current count)\r\n     *\r\n     * @param value The value to be recorded\r\n     * @param count The number of occurrences of this value to record\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\r\n        this.recordCountAtValue(count, value);\r\n    };\r\n    /**\r\n     * Record a value in the histogram.\r\n     * <p>\r\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\r\n     * (down to the expectedIntervalBetweenValueSamples) value records.\r\n     * <p>\r\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\r\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\r\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\r\n     * for the same coordinated omission issue.\r\n     * <p>\r\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\r\n     * important.\r\n     *\r\n     * @param value The value to record\r\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n     *                                           auto-generated value records as appropriate if value is larger\r\n     *                                           than expectedIntervalBetweenValueSamples\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\r\n    };\r\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\r\n        this.recordCountAtValue(count, value);\r\n        if (expectedIntervalBetweenValueSamples <= 0) {\r\n            return;\r\n        }\r\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\r\n            this.recordCountAtValue(count, missingValue);\r\n        }\r\n    };\r\n    /**\r\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\r\n     * <p>\r\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n     * interval between value samples, the values added will include an auto-generated additional series of\r\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\r\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\r\n     *\r\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\r\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\r\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\r\n     * for the same coordinated omission issue.\r\n     * by\r\n     * <p>\r\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\r\n     * important.\r\n     *\r\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\r\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n     *                                           auto-generated value records as appropriate if value is larger\r\n     *                                           than expectedIntervalBetweenValueSamples\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\r\n        var toHistogram = this;\r\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\r\n        while (otherValues.hasNext()) {\r\n            var v = otherValues.next();\r\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\r\n        }\r\n    };\r\n    /**\r\n     * Add the contents of another histogram to this one.\r\n     * <p>\r\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\r\n     * extended to include the start/end timestamp range of the other histogram.\r\n     *\r\n     * @param otherHistogram The other histogram.\r\n     * @throws (may throw) if values in fromHistogram's are\r\n     * higher than highestTrackableValue.\r\n     */\r\n    AbstractHistogram.prototype.add = function (otherHistogram) {\r\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\r\n        if (highestRecordableValue < otherHistogram.maxValue) {\r\n            if (!this.autoResize) {\r\n                throw \"The other histogram includes values that do not fit in this histogram's range.\";\r\n            }\r\n            this.resize(otherHistogram.maxValue);\r\n        }\r\n        if (this.bucketCount === otherHistogram.bucketCount &&\r\n            this.subBucketCount === otherHistogram.subBucketCount &&\r\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\r\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\r\n            var observedOtherTotalCount = 0;\r\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n                var otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    this.addToCountAtIndex(i, otherCount);\r\n                    observedOtherTotalCount += otherCount;\r\n                }\r\n            }\r\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\r\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\r\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\r\n        }\r\n        else {\r\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\r\n            // so we can't just stream through and add them. Instead, go through the array and add each\r\n            // non-zero value found at it's proper value:\r\n            // Do max value first, to avoid max value updates on each iteration:\r\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\r\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\r\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\r\n            // Record the remaining values, up to but not including the max value:\r\n            for (var i = 0; i < otherMaxIndex; i++) {\r\n                otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\r\n                }\r\n            }\r\n        }\r\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\r\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\r\n    };\r\n    /**\r\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\r\n     *\r\n     * @param value The value for which to provide the recorded count\r\n     * @return The total count of values recorded in the histogram within the value range that is\r\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\r\n     */\r\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\r\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\r\n        return this.getCountAtIndex(index);\r\n    };\r\n    /**\r\n     * Subtract the contents of another histogram from this one.\r\n     * <p>\r\n     * The start/end timestamps of this histogram will remain unchanged.\r\n     *\r\n     * @param otherHistogram The other histogram.\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\r\n     *\r\n     */\r\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\r\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\r\n        if (highestRecordableValue < otherHistogram.maxValue) {\r\n            if (!this.autoResize) {\r\n                throw \"The other histogram includes values that do not fit in this histogram's range.\";\r\n            }\r\n            this.resize(otherHistogram.maxValue);\r\n        }\r\n        if (this.bucketCount === otherHistogram.bucketCount &&\r\n            this.subBucketCount === otherHistogram.subBucketCount &&\r\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\r\n            // optim\r\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\r\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n                var otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    this.addToCountAtIndex(i, -otherCount);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n                var otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    var otherValue = otherHistogram.valueFromIndex(i);\r\n                    if (this.getCountAtValue(otherValue) < otherCount) {\r\n                        throw \"otherHistogram count (\" +\r\n                            otherCount +\r\n                            \") at value \" +\r\n                            otherValue +\r\n                            \" is larger than this one's (\" +\r\n                            this.getCountAtValue(otherValue) +\r\n                            \")\";\r\n                    }\r\n                    this.recordCountAtValue(-otherCount, otherValue);\r\n                }\r\n            }\r\n        }\r\n        // With subtraction, the max and minNonZero values could have changed:\r\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\r\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\r\n            this.establishInternalTackingValues();\r\n        }\r\n    };\r\n    AbstractHistogram.prototype.fillBufferFromCountsArray = function (buffer) {\r\n        var countsLimit = this.countsArrayIndex(this.maxValue) + 1;\r\n        var srcIndex = 0;\r\n        while (srcIndex < countsLimit) {\r\n            // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\r\n            // while negative values indicate a repeat zero counts.\r\n            var count = this.getCountAtIndex(srcIndex++);\r\n            if (count < 0) {\r\n                throw \"Cannot encode histogram containing negative counts (\" +\r\n                    count +\r\n                    \") at index \" +\r\n                    srcIndex +\r\n                    \", corresponding the value range [\" +\r\n                    this.lowestEquivalentValue(this.valueFromIndex(srcIndex)) +\r\n                    \",\" +\r\n                    this.nextNonEquivalentValue(this.valueFromIndex(srcIndex)) +\r\n                    \")\";\r\n            }\r\n            // Count trailing 0s (which follow this count):\r\n            var zerosCount = 0;\r\n            if (count == 0) {\r\n                zerosCount = 1;\r\n                while (srcIndex < countsLimit && this.getCountAtIndex(srcIndex) == 0) {\r\n                    zerosCount++;\r\n                    srcIndex++;\r\n                }\r\n            }\r\n            if (zerosCount > 1) {\r\n                ZigZagEncoding_1.default.encode(buffer, -zerosCount);\r\n            }\r\n            else {\r\n                ZigZagEncoding_1.default.encode(buffer, count);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Encode this histogram into a ByteBuffer\r\n     * @param buffer The buffer to encode into\r\n     * @return The number of bytes written to the buffer\r\n     */\r\n    AbstractHistogram.prototype.encodeIntoByteBuffer = function (buffer) {\r\n        var initialPosition = buffer.position;\r\n        buffer.putInt32(encodingCookie);\r\n        buffer.putInt32(0); // Placeholder for payload length in bytes.\r\n        buffer.putInt32(1);\r\n        buffer.putInt32(this.numberOfSignificantValueDigits);\r\n        buffer.putInt64(this.lowestDiscernibleValue);\r\n        buffer.putInt64(this.highestTrackableValue);\r\n        buffer.putInt64(1);\r\n        var payloadStartPosition = buffer.position;\r\n        this.fillBufferFromCountsArray(buffer);\r\n        var backupIndex = buffer.position;\r\n        buffer.position = initialPosition + 4;\r\n        buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\r\n        buffer.position = backupIndex;\r\n        return backupIndex - initialPosition;\r\n    };\r\n    AbstractHistogram.prototype.fillCountsArrayFromSourceBuffer = function (sourceBuffer, lengthInBytes, wordSizeInBytes) {\r\n        if (wordSizeInBytes != 2 &&\r\n            wordSizeInBytes != 4 &&\r\n            wordSizeInBytes != 8 &&\r\n            wordSizeInBytes != V2maxWordSizeInBytes) {\r\n            throw \"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\r\n                V2maxWordSizeInBytes +\r\n                \") bytes\";\r\n        }\r\n        var dstIndex = 0;\r\n        var endPosition = sourceBuffer.position + lengthInBytes;\r\n        while (sourceBuffer.position < endPosition) {\r\n            var zerosCount = 0;\r\n            var count = ZigZagEncoding_1.default.decode(sourceBuffer);\r\n            if (count < 0) {\r\n                zerosCount = -count;\r\n                dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\r\n            }\r\n            else {\r\n                this.setCountAtIndex(dstIndex++, count);\r\n            }\r\n        }\r\n        return dstIndex; // this is the destination length\r\n    };\r\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\r\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\r\n        this.maxValue = 0;\r\n        this.minNonZeroValue = Number.MAX_VALUE;\r\n        var maxIndex = -1;\r\n        var minNonZeroIndex = -1;\r\n        var observedTotalCount = 0;\r\n        for (var index = 0; index < lengthToCover; index++) {\r\n            var countAtIndex = this.getCountAtIndex(index);\r\n            if (countAtIndex > 0) {\r\n                observedTotalCount += countAtIndex;\r\n                maxIndex = index;\r\n                if (minNonZeroIndex == -1 && index != 0) {\r\n                    minNonZeroIndex = index;\r\n                }\r\n            }\r\n        }\r\n        if (maxIndex >= 0) {\r\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\r\n        }\r\n        if (minNonZeroIndex >= 0) {\r\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\r\n        }\r\n        this.setTotalCount(observedTotalCount);\r\n    };\r\n    AbstractHistogram.getCookieBase = function (cookie) {\r\n        return cookie & ~0xf0;\r\n    };\r\n    AbstractHistogram.getWordSizeInBytesFromCookie = function (cookie) {\r\n        if (this.getCookieBase(cookie) == V2EncodingCookieBase ||\r\n            this.getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\r\n            return V2maxWordSizeInBytes;\r\n        }\r\n        var sizeByte = (cookie & 0xf0) >> 4;\r\n        return sizeByte & 0xe;\r\n    };\r\n    AbstractHistogram.decodeFromByteBuffer = function (buffer, histogramConstr, minBarForHighestTrackableValue) {\r\n        var cookie = buffer.getInt32();\r\n        var payloadLengthInBytes;\r\n        var numberOfSignificantValueDigits;\r\n        var lowestTrackableUnitValue;\r\n        var highestTrackableValue;\r\n        if (this.getCookieBase(cookie) === V2EncodingCookieBase) {\r\n            if (this.getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\r\n                throw \"The buffer does not contain a Histogram (no valid cookie found)\";\r\n            }\r\n            payloadLengthInBytes = buffer.getInt32();\r\n            buffer.getInt32(); // normalizingIndexOffset not used\r\n            numberOfSignificantValueDigits = buffer.getInt32();\r\n            lowestTrackableUnitValue = buffer.getInt64();\r\n            highestTrackableValue = buffer.getInt64();\r\n            buffer.getInt64(); // integerToDoubleValueConversionRatio not used\r\n        }\r\n        else {\r\n            throw \"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\";\r\n        }\r\n        highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\r\n        var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\r\n        var filledLength = histogram.fillCountsArrayFromSourceBuffer(buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\r\n        histogram.establishInternalTackingValues(filledLength);\r\n        return histogram;\r\n    };\r\n    AbstractHistogram.decodeFromCompressedByteBuffer = function (buffer, histogramConstr, minBarForHighestTrackableValue) {\r\n        var initialTargetPosition = buffer.position;\r\n        var cookie = buffer.getInt32();\r\n        if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\r\n            throw \"Encoding not supported, only V2 is supported\";\r\n        }\r\n        var lengthOfCompressedContents = buffer.getInt32();\r\n        var pako = require(\"pako/lib/inflate\");\r\n        var uncompressedBuffer = pako.inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\r\n        return this.decodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\r\n    };\r\n    /**\r\n     * Encode this histogram in compressed form into a byte array\r\n     * @param targetBuffer The buffer to encode into\r\n     * @return The number of bytes written to the array\r\n     */\r\n    AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = function (targetBuffer, compressionLevel) {\r\n        var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\r\n        var uncompressedLength = this.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\r\n        targetBuffer.putInt32(compressedEncodingCookie);\r\n        var pako = require(\"pako/lib/deflate\");\r\n        var compressionOptions = compressionLevel\r\n            ? { level: compressionLevel }\r\n            : {};\r\n        var compressedArray = pako.deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\r\n        targetBuffer.putInt32(compressedArray.byteLength);\r\n        targetBuffer.putArray(compressedArray);\r\n        return targetBuffer.position;\r\n    };\r\n    AbstractHistogram.prototype.reset = function () {\r\n        this.clearCounts();\r\n        this.setTotalCount(0);\r\n        this.startTimeStampMsec = 0;\r\n        this.endTimeStampMsec = 0;\r\n        this.tag = AbstractHistogramBase_1.NO_TAG;\r\n        this.maxValue = 0;\r\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\r\n    };\r\n    return AbstractHistogram;\r\n}(AbstractHistogramBase_1.AbstractHistogramBase));\r\nexports.default = AbstractHistogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\r\nexports.NO_TAG = \"NO TAG\";\r\nvar AbstractHistogramBase = /** @class */ (function (_super) {\r\n    __extends(AbstractHistogramBase, _super);\r\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\r\n    //intermediateUncompressedByteArray : number[] = null;\r\n    /* useless ?\r\n    getIntegerToDoubleValueConversionRatio(): number {\r\n        return this.integerToDoubleValueConversionRatio;\r\n    }\r\n  \r\n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\r\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\r\n    }*/\r\n    function AbstractHistogramBase() {\r\n        var _this = _super.call(this) || this;\r\n        _this.autoResize = false;\r\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\r\n        _this.endTimeStampMsec = 0;\r\n        _this.tag = exports.NO_TAG;\r\n        _this.integerToDoubleValueConversionRatio = 1.0;\r\n        _this.identity = 0;\r\n        _this.highestTrackableValue = 0;\r\n        _this.lowestDiscernibleValue = 0;\r\n        _this.numberOfSignificantValueDigits = 0;\r\n        _this.bucketCount = 0;\r\n        _this.subBucketCount = 0;\r\n        _this.countsArrayLength = 0;\r\n        _this.wordSizeInBytes = 0;\r\n        return _this;\r\n    }\r\n    return AbstractHistogramBase;\r\n}(EncodableHistogram_1.EncodableHistogram));\r\nexports.AbstractHistogramBase = AbstractHistogramBase;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramBase.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar pow = Math.pow, floor = Math.floor;\r\nvar TWO_POW_32 = pow(2, 32);\r\n/**\r\n * Mimic Java's ByteBufffer with big endian order\r\n */\r\nvar ByteBuffer = /** @class */ (function () {\r\n    function ByteBuffer(data) {\r\n        this.position = 0;\r\n        this.data = data;\r\n        this.int32ArrayForConvert = new Uint32Array(1);\r\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\r\n    }\r\n    ByteBuffer.allocate = function (size) {\r\n        if (size === void 0) { size = 16; }\r\n        return new ByteBuffer(new Uint8Array(size));\r\n    };\r\n    ByteBuffer.prototype.put = function (value) {\r\n        if (this.position === this.data.length) {\r\n            var oldArray = this.data;\r\n            this.data = new Uint8Array(this.data.length * 2);\r\n            this.data.set(oldArray);\r\n        }\r\n        this.data[this.position] = value;\r\n        this.position++;\r\n    };\r\n    ByteBuffer.prototype.putInt32 = function (value) {\r\n        if (this.data.length - this.position < 4) {\r\n            var oldArray = this.data;\r\n            this.data = new Uint8Array(this.data.length * 2 + 4);\r\n            this.data.set(oldArray);\r\n        }\r\n        this.int32ArrayForConvert[0] = value;\r\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\r\n        this.position += 4;\r\n    };\r\n    ByteBuffer.prototype.putInt64 = function (value) {\r\n        this.putInt32(floor(value / TWO_POW_32));\r\n        this.putInt32(value);\r\n    };\r\n    ByteBuffer.prototype.putArray = function (array) {\r\n        if (this.data.length - this.position < array.byteLength) {\r\n            var oldArray = this.data;\r\n            this.data = new Uint8Array(this.position + array.byteLength);\r\n            this.data.set(oldArray);\r\n        }\r\n        this.data.set(array, this.position);\r\n        this.position += array.byteLength;\r\n    };\r\n    ByteBuffer.prototype.get = function () {\r\n        var value = this.data[this.position];\r\n        this.position++;\r\n        return value;\r\n    };\r\n    ByteBuffer.prototype.getInt32 = function () {\r\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\r\n        var value = this.int32ArrayForConvert[0];\r\n        this.position += 4;\r\n        return value;\r\n    };\r\n    ByteBuffer.prototype.getInt64 = function () {\r\n        var high = this.getInt32();\r\n        var low = this.getInt32();\r\n        return high * TWO_POW_32 + low;\r\n    };\r\n    ByteBuffer.prototype.resetPosition = function () {\r\n        this.position = 0;\r\n    };\r\n    return ByteBuffer;\r\n}());\r\nexports.default = ByteBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ByteBuffer.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int32Histogram = /** @class */ (function (_super) {\r\n    __extends(Int32Histogram, _super);\r\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Uint32Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Int32Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Uint32Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Int32Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Int32Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Int32Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Int32Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + 4 * this.counts.length;\r\n    };\r\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Int32Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Int32Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int32Histogram.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\r\nvar base64 = require(\"base64-js\");\r\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\r\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\r\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\r\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String));\r\n    return AbstractHistogram_1.default.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\r\n};\r\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\r\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\r\n    var buffer = ByteBuffer_1.default.allocate();\r\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\r\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\r\n    return base64.fromByteArray(encodedBuffer);\r\n};\r\nexports.encodeIntoBase64String = encodeIntoBase64String;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encoding.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\r\n/**\r\n * Used for iterating through histogram values.\r\n */\r\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\r\n    function AbstractHistogramIterator() {\r\n        this.currentIterationValue = new HistogramIterationValue_1.default();\r\n    }\r\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\r\n        this.histogram = histogram;\r\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\r\n        this.arrayTotalCount = histogram.getTotalCount();\r\n        this.currentIndex = 0;\r\n        this.currentValueAtIndex = 0;\r\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\r\n        this.prevValueIteratedTo = 0;\r\n        this.totalCountToPrevIndex = 0;\r\n        this.totalCountToCurrentIndex = 0;\r\n        this.totalValueToCurrentIndex = 0;\r\n        this.countAtThisValue = 0;\r\n        this.freshSubBucket = true;\r\n        this.currentIterationValue.reset();\r\n    };\r\n    /**\r\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\r\n     * element rather than throwing an exception.)\r\n     *\r\n     * @return true if the iterator has more elements.\r\n     */\r\n    AbstractHistogramIterator.prototype.hasNext = function () {\r\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\r\n            throw \"Concurrent Modification Exception\";\r\n        }\r\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\r\n    };\r\n    /**\r\n     * Returns the next element in the iteration.\r\n     *\r\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\r\n     */\r\n    AbstractHistogramIterator.prototype.next = function () {\r\n        // Move through the sub buckets and buckets until we hit the next reporting level:\r\n        while (!this.exhaustedSubBuckets()) {\r\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\r\n            if (this.freshSubBucket) {\r\n                // Don't add unless we've incremented since last bucket...\r\n                this.totalCountToCurrentIndex += this.countAtThisValue;\r\n                this.totalValueToCurrentIndex +=\r\n                    this.countAtThisValue *\r\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\r\n                this.freshSubBucket = false;\r\n            }\r\n            if (this.reachedIterationLevel()) {\r\n                var valueIteratedTo = this.getValueIteratedTo();\r\n                Object.assign(this.currentIterationValue, {\r\n                    valueIteratedTo: valueIteratedTo,\r\n                    valueIteratedFrom: this.prevValueIteratedTo,\r\n                    countAtValueIteratedTo: this.countAtThisValue,\r\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\r\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\r\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\r\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\r\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\r\n                });\r\n                this.prevValueIteratedTo = valueIteratedTo;\r\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\r\n                this.incrementIterationLevel();\r\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\r\n                    throw \"Concurrent Modification Exception\";\r\n                }\r\n                return this.currentIterationValue;\r\n            }\r\n            this.incrementSubBucket();\r\n        }\r\n        throw \"Index Out Of Bounds Exception\";\r\n    };\r\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\r\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\r\n    };\r\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\r\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\r\n    };\r\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\r\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\r\n    };\r\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\r\n        return this.currentIndex >= this.histogram.countsArrayLength;\r\n    };\r\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\r\n        this.freshSubBucket = true;\r\n        this.currentIndex++;\r\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\r\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\r\n    };\r\n    return AbstractHistogramIterator;\r\n}());\r\nexports.default = AbstractHistogramIterator;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramIterator.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar leftPadding = function (size) {\r\n    return function (input) {\r\n        if (input.length < size) {\r\n            return \" \".repeat(size - input.length) + input;\r\n        }\r\n        return input;\r\n    };\r\n};\r\nexports.integerFormatter = function (size) {\r\n    var padding = leftPadding(size);\r\n    return function (integer) { return padding(\"\" + integer); };\r\n};\r\nexports.floatFormatter = function (size, fractionDigits) {\r\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\r\n        maximumFractionDigits: fractionDigits,\r\n        minimumFractionDigits: fractionDigits,\r\n        useGrouping: false\r\n    });\r\n    var padding = leftPadding(size);\r\n    return function (float) { return padding(numberFormatter.format(float)); };\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatters.ts\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pako\"\n// module id = 8\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 9\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EncodableHistogram = /** @class */ (function () {\r\n    function EncodableHistogram() {\r\n    }\r\n    return EncodableHistogram;\r\n}());\r\nexports.EncodableHistogram = EncodableHistogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/EncodableHistogram.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Float64Histogram = /** @class */ (function (_super) {\r\n    __extends(Float64Histogram, _super);\r\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Float64Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Float64Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Float64Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Float64Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Float64Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Float64Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Float64Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + 8 * this.counts.length;\r\n    };\r\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Float64Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Float64Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Float64Histogram.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a value point iterated through in a Histogram, with associated stats.\r\n * <ul>\r\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\r\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\r\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\r\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\r\n * range.</li>\r\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\r\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\r\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\r\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\r\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\r\n * values equal or smaller than valueIteratedTo.</li>\r\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\r\n * equal or smaller than valueIteratedTo.</li>\r\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\r\n * or smaller than valueIteratedTo.</li>\r\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\r\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\r\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\r\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\r\n * range of multiple percentiles in the requested percentile iteration points).</li>\r\n * </ul>\r\n */\r\nvar HistogramIterationValue = /** @class */ (function () {\r\n    function HistogramIterationValue() {\r\n        this.reset();\r\n    }\r\n    HistogramIterationValue.prototype.reset = function () {\r\n        this.valueIteratedTo = 0;\r\n        this.valueIteratedFrom = 0;\r\n        this.countAtValueIteratedTo = 0;\r\n        this.countAddedInThisIterationStep = 0;\r\n        this.totalCountToThisValue = 0;\r\n        this.totalValueToThisValue = 0;\r\n        this.percentile = 0.0;\r\n        this.percentileLevelIteratedTo = 0.0;\r\n    };\r\n    return HistogramIterationValue;\r\n}());\r\nexports.default = HistogramIterationValue;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramIterationValue.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\r\nvar encoding_1 = require(\"./encoding\");\r\nvar TAG_PREFIX = \"Tag=\";\r\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\r\n/**\r\n * A histogram log reader.\r\n * <p>\r\n * Histogram logs are used to capture full fidelity, per-time-interval\r\n * histograms of a recorded value.\r\n * <p>\r\n * For example, a histogram log can be used to capture high fidelity\r\n * reaction-time logs for some measured system or subsystem component.\r\n * Such a log would capture a full reaction time histogram for each\r\n * logged interval, and could be used to later reconstruct a full\r\n * HdrHistogram of the measured reaction time behavior for any arbitrary\r\n * time range within the log, by adding [only] the relevant interval\r\n * histograms.\r\n * <h3>Histogram log format:</h3>\r\n * A histogram log file consists of text lines. Lines beginning with\r\n * the \"#\" character are optional and treated as comments. Lines\r\n * containing the legend (starting with \"Timestamp\") are also optional\r\n * and ignored in parsing the histogram log. All other lines must\r\n * be valid interval description lines. Text fields are delimited by\r\n * commas, spaces.\r\n * <p>\r\n * A valid interval description line contains an optional Tag=tagString\r\n * text field, followed by an interval description.\r\n * <p>\r\n * A valid interval description must contain exactly four text fields:\r\n * <ul>\r\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\r\n * representing the start timestamp of the interval in seconds.</li>\r\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\r\n * representing the length of the interval in seconds.</li>\r\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\r\n * which generally represents the maximum value of the interval histogram.</li>\r\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\r\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\r\n * </ul>\r\n * The log file may contain an optional indication of a starting time. Starting time\r\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\r\n * by a number parse-able as a double, representing the start time (in seconds)\r\n * that may be added to timestamps in the file to determine an absolute\r\n * timestamp (e.g. since the epoch) for each interval.\r\n */\r\nvar HistogramLogReader = /** @class */ (function () {\r\n    function HistogramLogReader(logContent) {\r\n        this.lines = splitLines(logContent);\r\n        this.currentLineIndex = 0;\r\n    }\r\n    /**\r\n     * Read the next interval histogram from the log. Returns a Histogram object if\r\n     * an interval line was found, or null if not.\r\n     * <p>Upon encountering any unexpected format errors in reading the next interval\r\n     * from the file, this method will return a null.\r\n     * @return a DecodedInterval, or a null if no appropriate interval found\r\n     */\r\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\r\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\r\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\r\n        while (this.currentLineIndex < this.lines.length) {\r\n            var currentLine = this.lines[this.currentLineIndex];\r\n            this.currentLineIndex++;\r\n            if (currentLine.startsWith(\"#[StartTime:\")) {\r\n                this.parseStartTimeFromLine(currentLine);\r\n            }\r\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\r\n                this.parseBaseTimeFromLine(currentLine);\r\n            }\r\n            else if (currentLine.startsWith(\"#\") ||\r\n                currentLine.startsWith('\"StartTimestamp\"')) {\r\n                // skip legend & meta data for now\r\n            }\r\n            else if (currentLine.includes(\",\")) {\r\n                var tokens = currentLine.split(\",\");\r\n                var firstToken = tokens[0];\r\n                var tag = void 0;\r\n                if (firstToken.startsWith(TAG_PREFIX)) {\r\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\r\n                    tokens.shift();\r\n                }\r\n                else {\r\n                    tag = AbstractHistogramBase_1.NO_TAG;\r\n                }\r\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\r\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\r\n                if (!this.baseTimeSec) {\r\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\r\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\r\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\r\n                        // StartTime), we assume that timestamps in the log are not absolute\r\n                        this.baseTimeSec = this.startTimeSec;\r\n                    }\r\n                    else {\r\n                        // Timestamps are absolute\r\n                        this.baseTimeSec = 0.0;\r\n                    }\r\n                }\r\n                if (rangeEndTimeSec < logTimeStampInSec) {\r\n                    return null;\r\n                }\r\n                if (logTimeStampInSec < rangeStartTimeSec) {\r\n                    continue;\r\n                }\r\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram);\r\n                histogram.startTimeStampMsec =\r\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\r\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\r\n                histogram.endTimeStampMsec =\r\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\r\n                histogram.tag = tag;\r\n                return histogram;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\r\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\r\n    };\r\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\r\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\r\n    };\r\n    return HistogramLogReader;\r\n}());\r\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\r\nvar shouldIncludeNoTag = function (lines) {\r\n    return lines.find(function (line) {\r\n        return !line.startsWith(\"#\") &&\r\n            !line.startsWith('\"') &&\r\n            !line.startsWith(TAG_PREFIX) &&\r\n            line.includes(\",\");\r\n    });\r\n};\r\nexports.listTags = function (content) {\r\n    var lines = splitLines(content);\r\n    var tags = lines\r\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\r\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\r\n    var tagsWithoutDuplicates = new Set(tags);\r\n    var result = Array.from(tagsWithoutDuplicates);\r\n    if (shouldIncludeNoTag(lines)) {\r\n        result.unshift(\"NO TAG\");\r\n    }\r\n    return result;\r\n};\r\nexports.default = HistogramLogReader;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogReader.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\r\nvar encoding_1 = require(\"./encoding\");\r\nvar formatters_1 = require(\"./formatters\");\r\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\r\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\r\nvar HistogramLogWriter = /** @class */ (function () {\r\n    function HistogramLogWriter(log) {\r\n        this.log = log;\r\n        /**\r\n           * Base time to subtract from supplied histogram start/end timestamps when\r\n           * logging based on histogram timestamps.\r\n           * Base time is expected to be in msec since the epoch, as histogram start/end times\r\n           * are typically stamped with absolute times in msec since the epoch.\r\n           */\r\n        this.baseTime = 0;\r\n    }\r\n    /**\r\n       * Output an interval histogram, with the given timestamp information and the [optional] tag\r\n       * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\r\n       * specified timestamp information will be used, and the timestamp information in the actual\r\n       * histogram will be ignored).\r\n       * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\r\n       * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\r\n       * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\r\n       * @param histogram The interval histogram to log.\r\n       * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\r\n       */\r\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\r\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\r\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\r\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\r\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\r\n        var start = timeFormatter(startTimeStampSec);\r\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\r\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\r\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\r\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\r\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\r\n        }\r\n        else {\r\n            this.log(lineContent);\r\n        }\r\n    };\r\n    /**\r\n       * Log a comment to the log.\r\n       * Comments will be preceded with with the '#' character.\r\n       * @param comment the comment string.\r\n       */\r\n    HistogramLogWriter.prototype.outputComment = function (comment) {\r\n        this.log(\"#\" + comment + \"\\n\");\r\n    };\r\n    /**\r\n       * Log a start time in the log.\r\n       * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\r\n       */\r\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\r\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\r\n    };\r\n    /**\r\n       * Output a legend line to the log.\r\n       */\r\n    HistogramLogWriter.prototype.outputLegend = function () {\r\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\r\n    };\r\n    /**\r\n       * Output a log format version to the log.\r\n       */\r\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\r\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\r\n    };\r\n    return HistogramLogWriter;\r\n}());\r\nexports.default = HistogramLogWriter;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogWriter.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int16Histogram = /** @class */ (function (_super) {\r\n    __extends(Int16Histogram, _super);\r\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Uint16Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Int16Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Uint16Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Int16Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Int16Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Int16Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Int16Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + 2 * this.counts.length;\r\n    };\r\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Int16Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Int16Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int16Histogram.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int8Histogram = /** @class */ (function (_super) {\r\n    __extends(Int8Histogram, _super);\r\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Uint8Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Int8Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Uint8Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Int8Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Int8Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Int8Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Int8Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + this.counts.length;\r\n    };\r\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Int8Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Int8Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int8Histogram.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\r\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\r\n/**\r\n * Used for iterating through histogram values according to percentile levels. The iteration is\r\n * performed in steps that start at 0% and reduce their distance to 100% according to the\r\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\r\n * values are exhausted.\r\n */\r\nvar PercentileIterator = /** @class */ (function (_super) {\r\n    __extends(PercentileIterator, _super);\r\n    /**\r\n       * @param histogram The histogram this iterator will operate on\r\n       * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\r\n       */\r\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\r\n        var _this = _super.call(this) || this;\r\n        _this.percentileTicksPerHalfDistance = 0;\r\n        _this.percentileLevelToIterateTo = 0;\r\n        _this.percentileLevelToIterateFrom = 0;\r\n        _this.reachedLastRecordedValue = false;\r\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\r\n        return _this;\r\n    }\r\n    /**\r\n       * Reset iterator for re-use in a fresh iteration over the same histogram data set.\r\n       *\r\n       * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\r\n       */\r\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\r\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\r\n    };\r\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\r\n        _super.prototype.resetIterator.call(this, histogram);\r\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\r\n        this.percentileLevelToIterateTo = 0;\r\n        this.percentileLevelToIterateFrom = 0;\r\n        this.reachedLastRecordedValue = false;\r\n    };\r\n    PercentileIterator.prototype.hasNext = function () {\r\n        if (_super.prototype.hasNext.call(this))\r\n            return true;\r\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\r\n            this.percentileLevelToIterateTo = 100;\r\n            this.reachedLastRecordedValue = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    PercentileIterator.prototype.incrementIterationLevel = function () {\r\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\r\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\r\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\r\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\r\n        // steps are much easier to browse through in a percentile distribution output, for example.\r\n        //\r\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\r\n        // by at the current scale. The scale is detemined by the percentile level we are\r\n        // iterating to. The following math determines the tick size for the current scale,\r\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\r\n        // [from either 0% or from the previous half-distance]. When that half-distance is\r\n        // crossed, the scale changes and the tick size is effectively cut in half.\r\n        // percentileTicksPerHalfDistance = 5\r\n        // percentileReportingTicks = 10,\r\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\r\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\r\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\r\n    };\r\n    PercentileIterator.prototype.reachedIterationLevel = function () {\r\n        if (this.countAtThisValue === 0) {\r\n            return false;\r\n        }\r\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\r\n        return currentPercentile >= this.percentileLevelToIterateTo;\r\n    };\r\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\r\n        return this.percentileLevelToIterateTo;\r\n    };\r\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\r\n        return this.percentileLevelToIterateFrom;\r\n    };\r\n    return PercentileIterator;\r\n}(AbstractHistogramIterator_1.default));\r\nexports.default = PercentileIterator;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PercentileIterator.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\r\n/**\r\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\r\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\r\n * all recorded histogram values are exhausted.\r\n */\r\nvar RecordedValuesIterator = /** @class */ (function (_super) {\r\n    __extends(RecordedValuesIterator, _super);\r\n    /**\r\n     * @param histogram The histogram this iterator will operate on\r\n     */\r\n    function RecordedValuesIterator(histogram) {\r\n        var _this = _super.call(this) || this;\r\n        _this.doReset(histogram);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\r\n     */\r\n    RecordedValuesIterator.prototype.reset = function () {\r\n        this.doReset(this.histogram);\r\n    };\r\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\r\n        _super.prototype.resetIterator.call(this, histogram);\r\n        this.visitedIndex = -1;\r\n    };\r\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\r\n        this.visitedIndex = this.currentIndex;\r\n    };\r\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\r\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\r\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\r\n    };\r\n    return RecordedValuesIterator;\r\n}(AbstractHistogramIterator_1.default));\r\nexports.default = RecordedValuesIterator;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RecordedValuesIterator.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\r\n/**\r\n * Records integer values, and provides stable interval {@link Histogram} samples from\r\n * live recorded data without interrupting or stalling active recording of values. Each interval\r\n * histogram provided contains all value counts accumulated since the previous interval histogram\r\n * was taken.\r\n * <p>\r\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\r\n * <p>\r\n * {@link Recorder} supports concurrent\r\n * {@link Recorder#recordValue} or\r\n * {@link Recorder#recordValueWithExpectedInterval} calls.\r\n *\r\n */\r\nvar Recorder = /** @class */ (function () {\r\n    /**\r\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\r\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\r\n     *\r\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\r\n     *                                       decimal digits to which the histogram will maintain value resolution\r\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\r\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\r\n     */\r\n    function Recorder(numberOfSignificantValueDigits, clock) {\r\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\r\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\r\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\r\n        this.clock = clock;\r\n        this.activeHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\r\n        Recorder.idGenerator++;\r\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\r\n        this.activeHistogram.startTimeStampMsec = clock();\r\n    }\r\n    /**\r\n     * Record a value in the histogram\r\n     *\r\n     * @param value The value to be recorded\r\n     * @throws may throw Error if value is exceeds highestTrackableValue\r\n     */\r\n    Recorder.prototype.recordValue = function (value) {\r\n        this.activeHistogram.recordValue(value);\r\n    };\r\n    /**\r\n     * Record a value in the histogram (adding to the value's current count)\r\n     *\r\n     * @param value The value to be recorded\r\n     * @param count The number of occurrences of this value to record\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    Recorder.prototype.recordValueWithCount = function (value, count) {\r\n        this.activeHistogram.recordValueWithCount(value, count);\r\n    };\r\n    /**\r\n     * Record a value\r\n     * <p>\r\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\r\n     * (down to the expectedIntervalBetweenValueSamples) value records.\r\n     * <p>\r\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\r\n     * for more explanations about coordinated omission and expected interval correction.\r\n     *      *\r\n     * @param value The value to record\r\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n     *                                           auto-generated value records as appropriate if value is larger\r\n     *                                           than expectedIntervalBetweenValueSamples\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\r\n    };\r\n    /**\r\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\r\n     * accumulated since the last interval histogram was taken.\r\n     * <p>\r\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n     * getIntervalHistogram(histogramToRecycle)}\r\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\r\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\r\n     * {@link Recorder#getIntervalHistogram()} and\r\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\r\n     * {@code histogramToRecycle} must\r\n     * be either be null or an interval histogram returned by a previous call to\r\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n     * getIntervalHistogram(histogramToRecycle)} or\r\n     * {@link Recorder#getIntervalHistogram()}.\r\n     * <p>\r\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\r\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\r\n     * <p>\r\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\r\n     * counts for the next interval\r\n     *\r\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\r\n     *                           copy operations.\r\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\r\n     */\r\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\r\n        if (histogramToRecycle) {\r\n            var histogramToRecycleWithId = histogramToRecycle;\r\n            if (histogramToRecycleWithId.containingInstanceId !==\r\n                this.activeHistogram.containingInstanceId) {\r\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\r\n            }\r\n        }\r\n        this.inactiveHistogram = histogramToRecycle;\r\n        this.performIntervalSample();\r\n        var sampledHistogram = this.inactiveHistogram;\r\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\r\n        return sampledHistogram;\r\n    };\r\n    /**\r\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\r\n     * was taken) into {@code targetHistogram}.\r\n     *\r\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\r\n     * the value counts, and start accumulating value counts for the next interval.\r\n     *\r\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\r\n     */\r\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\r\n        this.performIntervalSample();\r\n        if (this.inactiveHistogram) {\r\n            targetHistogram.add(this.inactiveHistogram);\r\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\r\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\r\n        }\r\n    };\r\n    /**\r\n     * Reset any value counts accumulated thus far.\r\n     */\r\n    Recorder.prototype.reset = function () {\r\n        this.activeHistogram.reset();\r\n        this.activeHistogram.startTimeStampMsec = this.clock();\r\n    };\r\n    Recorder.prototype.performIntervalSample = function () {\r\n        if (!this.inactiveHistogram) {\r\n            this.inactiveHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\r\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\r\n        }\r\n        this.inactiveHistogram.reset();\r\n        var tempHistogram = this.activeHistogram;\r\n        this.activeHistogram = this.inactiveHistogram;\r\n        this.inactiveHistogram = tempHistogram;\r\n        var currentTimeInMs = this.clock();\r\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\r\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\r\n    };\r\n    Recorder.idGenerator = 0;\r\n    return Recorder;\r\n}());\r\nexports.default = Recorder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Recorder.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar pow = Math.pow, floor = Math.floor;\r\nvar TWO_POW_7 = pow(2, 7);\r\nvar TWO_POW_14 = pow(2, 14);\r\nvar TWO_POW_21 = pow(2, 21);\r\nvar TWO_POW_28 = pow(2, 28);\r\nvar TWO_POW_35 = pow(2, 35);\r\nvar TWO_POW_42 = pow(2, 42);\r\nvar TWO_POW_49 = pow(2, 49);\r\nvar TWO_POW_56 = pow(2, 56);\r\n/**\r\n * This class provides encoding and decoding methods for writing and reading\r\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\r\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\r\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\r\n * allows small (closer to zero) negative values to use fewer bytes. Details\r\n * on both LEB128 and ZigZag can be readily found elsewhere.\r\n *\r\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\r\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\r\n * value can take up to 10 bytes in the stream, where this variant's encoding\r\n * of a 64 bit values will max out at 9 bytes.\r\n *\r\n * As such, this encoder/decoder should NOT be used for encoding or decoding\r\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\r\n */\r\nvar ZigZagEncoding = /** @class */ (function () {\r\n    function ZigZagEncoding() {\r\n    }\r\n    /**\r\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\r\n     * (negative numbers not supported)\r\n     * @param buffer the buffer to write to\r\n     * @param value  the value to write to the buffer\r\n     */\r\n    ZigZagEncoding.encode = function (buffer, value) {\r\n        if (value >= 0) {\r\n            value = value * 2;\r\n        }\r\n        else {\r\n            value = -value * 2 - 1;\r\n        }\r\n        if (value < TWO_POW_7) {\r\n            buffer.put(value);\r\n        }\r\n        else {\r\n            buffer.put(value % 0x80 + 0x80);\r\n            if (value < TWO_POW_14) {\r\n                buffer.put(floor(value / TWO_POW_7));\r\n            }\r\n            else {\r\n                buffer.put(floor(value / TWO_POW_7) + 0x80);\r\n                if (value < TWO_POW_21) {\r\n                    buffer.put(floor(value / TWO_POW_14));\r\n                }\r\n                else {\r\n                    buffer.put(floor(value / TWO_POW_14) + 0x80);\r\n                    if (value < TWO_POW_28) {\r\n                        buffer.put(floor(value / TWO_POW_21));\r\n                    }\r\n                    else {\r\n                        buffer.put(floor(value / TWO_POW_21) + 0x80);\r\n                        if (value < TWO_POW_35) {\r\n                            buffer.put(floor(value / TWO_POW_28));\r\n                        }\r\n                        else {\r\n                            buffer.put(floor(value / TWO_POW_28) + 0x80);\r\n                            if (value < TWO_POW_42) {\r\n                                buffer.put(floor(value / TWO_POW_35));\r\n                            }\r\n                            else {\r\n                                buffer.put(floor(value / TWO_POW_35) + 0x80);\r\n                                if (value < TWO_POW_49) {\r\n                                    buffer.put(floor(value / TWO_POW_42));\r\n                                }\r\n                                else {\r\n                                    buffer.put(floor(value / TWO_POW_42) + 0x80);\r\n                                    if (value < TWO_POW_56) {\r\n                                        buffer.put(floor(value / TWO_POW_49));\r\n                                    }\r\n                                    else {\r\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\r\n                                        buffer.put(floor(value / TWO_POW_56));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\r\n     * (negative numbers not supported)\r\n     * @param buffer the buffer to read from\r\n     * @return the value read from the buffer\r\n     */\r\n    ZigZagEncoding.decode = function (buffer) {\r\n        var v = buffer.get();\r\n        var value = v & 0x7f;\r\n        if ((v & 0x80) != 0) {\r\n            v = buffer.get();\r\n            value += (v & 0x7f) * TWO_POW_7;\r\n            if ((v & 0x80) != 0) {\r\n                v = buffer.get();\r\n                value += (v & 0x7f) * TWO_POW_14;\r\n                if ((v & 0x80) != 0) {\r\n                    v = buffer.get();\r\n                    value += (v & 0x7f) * TWO_POW_21;\r\n                    if ((v & 0x80) != 0) {\r\n                        v = buffer.get();\r\n                        value += (v & 0x7f) * TWO_POW_28;\r\n                        if ((v & 0x80) != 0) {\r\n                            v = buffer.get();\r\n                            value += (v & 0x7f) * TWO_POW_35;\r\n                            if ((v & 0x80) != 0) {\r\n                                v = buffer.get();\r\n                                value += (v & 0x7f) * TWO_POW_42;\r\n                                if ((v & 0x80) != 0) {\r\n                                    v = buffer.get();\r\n                                    value += (v & 0x7f) * TWO_POW_49;\r\n                                    if ((v & 0x80) != 0) {\r\n                                        v = buffer.get();\r\n                                        value += (v & 0x7f) * TWO_POW_56;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (value % 2 === 0) {\r\n            value = value / 2;\r\n        }\r\n        else {\r\n            value = -(value + 1) / 2;\r\n        }\r\n        return value;\r\n    };\r\n    return ZigZagEncoding;\r\n}());\r\nexports.default = ZigZagEncoding;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ZigZagEncoding.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\r\nexports.ByteBuffer = ByteBuffer_1.default;\r\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\r\nexports.Int8Histogram = Int8Histogram_1.default;\r\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\r\nexports.Int16Histogram = Int16Histogram_1.default;\r\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\r\nexports.Int32Histogram = Int32Histogram_1.default;\r\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\r\nexports.Float64Histogram = Float64Histogram_1.default;\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nexports.AbstractHistogram = AbstractHistogram_1.default;\r\nexports.Histogram = AbstractHistogram_1.default;\r\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\r\nexports.HistogramLogReader = HistogramLogReader_1.default;\r\nexports.listTags = HistogramLogReader_1.listTags;\r\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\r\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\r\nvar encoding_1 = require(\"./encoding\");\r\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\r\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\r\nvar Recorder_1 = require(\"./Recorder\");\r\nexports.Recorder = Recorder_1.default;\r\nvar defaultRequest = {\r\n    bitBucketSize: 32,\r\n    autoResize: true,\r\n    lowestDiscernibleValue: 1,\r\n    highestTrackableValue: 2,\r\n    numberOfSignificantValueDigits: 3\r\n};\r\nexports.defaultRequest = defaultRequest;\r\nvar build = function (request) {\r\n    if (request === void 0) { request = defaultRequest; }\r\n    var parameters = Object.assign({}, defaultRequest, request);\r\n    var histogramConstr;\r\n    switch (parameters.bitBucketSize) {\r\n        case 8:\r\n            histogramConstr = Int8Histogram_1.default;\r\n            break;\r\n        case 16:\r\n            histogramConstr = Int16Histogram_1.default;\r\n            break;\r\n        case 32:\r\n            histogramConstr = Int32Histogram_1.default;\r\n            break;\r\n        default:\r\n            histogramConstr = Float64Histogram_1.default;\r\n    }\r\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\r\n    histogram.autoResize = parameters.autoResize;\r\n    return histogram;\r\n};\r\nexports.build = build;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\r\nexports.default = ulp;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ulp.ts\n// module id = 22\n// module chunks = 0"],"sourceRoot":""}