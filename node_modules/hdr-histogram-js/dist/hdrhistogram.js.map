{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e9220dc0fb85ea6b5a28","webpack:///./src/index.ts","webpack:///./src/ByteBuffer.ts","webpack:///./src/Int8Histogram.ts","webpack:///./src/AbstractHistogram.ts","webpack:///./src/AbstractHistogramBase.ts","webpack:///./src/EncodableHistogram.ts","webpack:///./src/RecordedValuesIterator.ts","webpack:///./src/AbstractHistogramIterator.ts","webpack:///./src/HistogramIterationValue.ts","webpack:///./src/PercentileIterator.ts","webpack:///./src/formatters.ts","webpack:///./src/ZigZagEncoding.ts","webpack:///./src/ulp.ts","webpack:///external \"pako\"","webpack:///./src/Int16Histogram.ts","webpack:///./src/Int32Histogram.ts","webpack:///./src/Float64Histogram.ts","webpack:///./src/HistogramLogReader.ts","webpack:///./src/encoding.ts","webpack:///./~/base64-js/index.js","webpack:///./src/HistogramLogWriter.ts","webpack:///./src/Recorder.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,0BAA0B;AACvD,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACvEA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,kDAAiD;AACjD,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,SAAQ,6DAA6D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,oCAAoC;AAC5F,sDAAqD,iCAAiC;AACtF,uCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E,qDAAqD;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E,qDAAqD;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,mFAAmF;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,YAAY,0CAA0C,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA,wCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACh5BA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtDA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClDA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC9FA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,8BAA6B,+CAA+C;AAC5E;;;;;;;ACtBA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D,yBAAwB,mDAAmD;AAC3E;;;;;;;ACVA,iD;;;;;;ACAA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,uBAAuB;AAClE,0CAAyC,oCAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,yCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kCAAiC,0DAA0D,EAAE;AAC7F,+BAA8B,6DAA6D,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1JA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,4CAA4C;AACjF,qDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1BA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACjHA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,2EAA2E;AACtH,0CAAyC,uEAAuE;AAChH,4CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA,0DAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,eAAe;AACnB,KAAI,2BAA2B;AAC/B,KAAI,+CAA+C;AACnD;AACA;AACA;AACA;AACA,oCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,oCAAoC;AAC5F,gCAA+B,sBAAsB,6BAA6B,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ,sCAAsC;AAC9C,SAAQ,mEAAmE;AAC3E,SAAQ,yBAAyB;AACjC;AACA,SAAQ;AACR,iDAAgD;AAChD,SAAQ,sCAAsC;AAC9C;AACA;AACA;AACA;AACA,iBAAgB;AAChB,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA,yBAAwB,sBAAsB;AAC9C;AACA,iBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD","file":"hdrhistogram.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_14__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e9220dc0fb85ea6b5a28","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\r\nexports.ByteBuffer = ByteBuffer_1.default;\r\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\r\nexports.Int8Histogram = Int8Histogram_1.default;\r\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\r\nexports.Int16Histogram = Int16Histogram_1.default;\r\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\r\nexports.Int32Histogram = Int32Histogram_1.default;\r\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\r\nexports.Float64Histogram = Float64Histogram_1.default;\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nexports.AbstractHistogram = AbstractHistogram_1.default;\r\nexports.Histogram = AbstractHistogram_1.default;\r\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\r\nexports.HistogramLogReader = HistogramLogReader_1.default;\r\nexports.listTags = HistogramLogReader_1.listTags;\r\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\r\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\r\nvar encoding_1 = require(\"./encoding\");\r\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\r\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\r\nvar Recorder_1 = require(\"./Recorder\");\r\nexports.Recorder = Recorder_1.default;\r\nvar defaultRequest = {\r\n    bitBucketSize: 32,\r\n    autoResize: true,\r\n    lowestDiscernibleValue: 1,\r\n    highestTrackableValue: 2,\r\n    numberOfSignificantValueDigits: 3\r\n};\r\nexports.defaultRequest = defaultRequest;\r\nvar build = function (request) {\r\n    if (request === void 0) { request = defaultRequest; }\r\n    var parameters = Object.assign({}, defaultRequest, request);\r\n    var histogramConstr;\r\n    switch (parameters.bitBucketSize) {\r\n        case 8:\r\n            histogramConstr = Int8Histogram_1.default;\r\n            break;\r\n        case 16:\r\n            histogramConstr = Int16Histogram_1.default;\r\n            break;\r\n        case 32:\r\n            histogramConstr = Int32Histogram_1.default;\r\n            break;\r\n        default:\r\n            histogramConstr = Float64Histogram_1.default;\r\n    }\r\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\r\n    histogram.autoResize = parameters.autoResize;\r\n    return histogram;\r\n};\r\nexports.build = build;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar pow = Math.pow, floor = Math.floor;\r\nvar TWO_POW_32 = pow(2, 32);\r\n/**\r\n * Mimic Java's ByteBufffer with big endian order\r\n */\r\nvar ByteBuffer = /** @class */ (function () {\r\n    function ByteBuffer(data) {\r\n        this.position = 0;\r\n        this.data = data;\r\n        this.int32ArrayForConvert = new Uint32Array(1);\r\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\r\n    }\r\n    ByteBuffer.allocate = function (size) {\r\n        if (size === void 0) { size = 16; }\r\n        return new ByteBuffer(new Uint8Array(size));\r\n    };\r\n    ByteBuffer.prototype.put = function (value) {\r\n        if (this.position === this.data.length) {\r\n            var oldArray = this.data;\r\n            this.data = new Uint8Array(this.data.length * 2);\r\n            this.data.set(oldArray);\r\n        }\r\n        this.data[this.position] = value;\r\n        this.position++;\r\n    };\r\n    ByteBuffer.prototype.putInt32 = function (value) {\r\n        if (this.data.length - this.position < 4) {\r\n            var oldArray = this.data;\r\n            this.data = new Uint8Array(this.data.length * 2 + 4);\r\n            this.data.set(oldArray);\r\n        }\r\n        this.int32ArrayForConvert[0] = value;\r\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\r\n        this.position += 4;\r\n    };\r\n    ByteBuffer.prototype.putInt64 = function (value) {\r\n        this.putInt32(floor(value / TWO_POW_32));\r\n        this.putInt32(value);\r\n    };\r\n    ByteBuffer.prototype.putArray = function (array) {\r\n        if (this.data.length - this.position < array.byteLength) {\r\n            var oldArray = this.data;\r\n            this.data = new Uint8Array(this.position + array.byteLength);\r\n            this.data.set(oldArray);\r\n        }\r\n        this.data.set(array, this.position);\r\n        this.position += array.byteLength;\r\n    };\r\n    ByteBuffer.prototype.get = function () {\r\n        var value = this.data[this.position];\r\n        this.position++;\r\n        return value;\r\n    };\r\n    ByteBuffer.prototype.getInt32 = function () {\r\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\r\n        var value = this.int32ArrayForConvert[0];\r\n        this.position += 4;\r\n        return value;\r\n    };\r\n    ByteBuffer.prototype.getInt64 = function () {\r\n        var high = this.getInt32();\r\n        var low = this.getInt32();\r\n        return high * TWO_POW_32 + low;\r\n    };\r\n    ByteBuffer.prototype.resetPosition = function () {\r\n        this.position = 0;\r\n    };\r\n    return ByteBuffer;\r\n}());\r\nexports.default = ByteBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ByteBuffer.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int8Histogram = /** @class */ (function (_super) {\r\n    __extends(Int8Histogram, _super);\r\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Uint8Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Int8Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Uint8Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Int8Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Int8Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Int8Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Int8Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + this.counts.length;\r\n    };\r\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Int8Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Int8Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int8Histogram.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\r\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\r\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\r\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\r\nvar formatters_1 = require(\"./formatters\");\r\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\r\nvar ulp_1 = require(\"./ulp\");\r\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\r\nvar V2EncodingCookieBase = 0x1c849303;\r\nvar V2CompressedEncodingCookieBase = 0x1c849304;\r\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\r\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\r\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\r\nvar AbstractHistogram = /** @class */ (function (_super) {\r\n    __extends(AbstractHistogram, _super);\r\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this) || this;\r\n        _this.maxValue = 0;\r\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\r\n        // Verify argument validity\r\n        if (lowestDiscernibleValue < 1) {\r\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\r\n        }\r\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\r\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue\");\r\n        }\r\n        if (numberOfSignificantValueDigits < 0 ||\r\n            numberOfSignificantValueDigits > 5) {\r\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\r\n        }\r\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\r\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\r\n        return _this;\r\n    }\r\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\r\n        var internalValue = value + this.unitMagnitudeMask;\r\n        this.maxValue = internalValue;\r\n    };\r\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\r\n        if (value <= this.unitMagnitudeMask) {\r\n            return;\r\n        }\r\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\r\n            this.lowestDiscernibleValueRounded;\r\n        this.minNonZeroValue = internalValue;\r\n    };\r\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\r\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\r\n            this.lowestDiscernibleValueRounded;\r\n        this.minNonZeroValue =\r\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\r\n                ? minNonZeroValue\r\n                : internalValue;\r\n    };\r\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\r\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\r\n        this.highestTrackableValue = highestTrackableValue;\r\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\r\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\r\n        if (normalizingIndexOffset !== 0) {\r\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\r\n        }\r\n        /*\r\n        * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\r\n        * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\r\n        * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\r\n        */\r\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\r\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\r\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\r\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\r\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\r\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\r\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\r\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\r\n        this.subBucketHalfCountMagnitude =\r\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\r\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\r\n        this.subBucketHalfCount = this.subBucketCount / 2;\r\n        this.subBucketMask =\r\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\r\n        this.establishSize(highestTrackableValue);\r\n        this.leadingZeroCountBase =\r\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\r\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\r\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\r\n    };\r\n    /**\r\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\r\n     *\r\n     * <pre>\r\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\r\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\r\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\r\n     * ...\r\n     * </pre>\r\n     *\r\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\r\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\r\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\r\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\r\n     * values as it has better precision.\r\n     */\r\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\r\n        // establish counts array length:\r\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\r\n        // establish exponent range needed to support the trackable value with no overflow:\r\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\r\n        // establish the new highest trackable value:\r\n        this.highestTrackableValue = newHighestTrackableValue;\r\n    };\r\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\r\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\r\n            throw new Error(\"highestTrackableValue (\" +\r\n                highestTrackableValue +\r\n                \") cannot be < (2 * lowestDiscernibleValue)\");\r\n        }\r\n        //determine counts array length needed:\r\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\r\n        return countsArrayLength;\r\n    };\r\n    /**\r\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\r\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\r\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\r\n     * value if we consider the sub-bucket length to be halved.\r\n     */\r\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\r\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\r\n        return lengthNeeded;\r\n    };\r\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\r\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\r\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\r\n        // always have at least 1 bucket\r\n        var bucketsNeeded = 1;\r\n        while (smallestUntrackableValue <= value) {\r\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\r\n                // TODO check array max size in JavaScript\r\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\r\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\r\n                return bucketsNeeded + 1;\r\n            }\r\n            smallestUntrackableValue = smallestUntrackableValue * 2;\r\n            bucketsNeeded++;\r\n        }\r\n        return bucketsNeeded;\r\n    };\r\n    /**\r\n     * Record a value in the histogram\r\n     *\r\n     * @param value The value to be recorded\r\n     * @throws may throw Error if value is exceeds highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.recordValue = function (value) {\r\n        this.recordSingleValue(value);\r\n    };\r\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\r\n        var countsIndex = this.countsArrayIndex(value);\r\n        if (countsIndex >= this.countsArrayLength) {\r\n            this.handleRecordException(1, value);\r\n        }\r\n        else {\r\n            this.incrementCountAtIndex(countsIndex);\r\n        }\r\n        this.updateMinAndMax(value);\r\n        this.incrementTotalCount();\r\n    };\r\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\r\n        if (!this.autoResize) {\r\n            throw \"Value \" + value + \" is outside of histogram covered range\";\r\n        }\r\n        this.resize(value);\r\n        var countsIndex = this.countsArrayIndex(value);\r\n        this.addToCountAtIndex(countsIndex, count);\r\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\r\n    };\r\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\r\n        if (value < 0) {\r\n            throw new Error(\"Histogram recorded value cannot be negative.\");\r\n        }\r\n        var bucketIndex = this.getBucketIndex(value);\r\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\r\n    };\r\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\r\n        // TODO\r\n        //assert(subBucketIndex < subBucketCount);\r\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\r\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\r\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\r\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\r\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\r\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\r\n        // However, this works out since we give bucket 0 twice as much space.\r\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\r\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\r\n        return bucketBaseIndex + offsetInBucket;\r\n    };\r\n    /**\r\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\r\n     */\r\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\r\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\r\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\r\n        // The mask maps small values to bucket 0.\r\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\r\n        return max(floor(log2(value)) -\r\n            this.subBucketHalfCountMagnitude -\r\n            this.unitMagnitude, 0);\r\n    };\r\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\r\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\r\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\r\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\r\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\r\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\r\n        // and therefore in the top half of subBucketCount.\r\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\r\n    };\r\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\r\n        if (value > this.maxValue) {\r\n            this.updatedMaxValue(value);\r\n        }\r\n        if (value < this.minNonZeroValue && value !== 0) {\r\n            this.updateMinNonZeroValue(value);\r\n        }\r\n    };\r\n    /**\r\n     * Get the value at a given percentile.\r\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\r\n     * percentage of the overall recorded value entries in the histogram are either smaller than\r\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\r\n     * entries in the histogram are either larger than or equivalent to.\r\n     * <p>\r\n     * Note that two values are \"equivalent\" in this statement if\r\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\r\n     *\r\n     * @param percentile  The percentile for which to return the associated value\r\n     * @return The value that the given percentage of the overall recorded value entries in the\r\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\r\n     * value that all value entries in the histogram are either larger than or equivalent to.\r\n     */\r\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\r\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\r\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\r\n        // of overall recorded values is actually included. However, this must be done with care:\r\n        //\r\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\r\n        // being 1 ulp larger than the correct integer count for this percentile:\r\n        var fpCountAtPercentile = requestedPercentile / 100.0 * this.getTotalCount();\r\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\r\n        // making us skip a count:\r\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\r\n        1 // Make sure we at least reach the first recorded entry\r\n        );\r\n        var totalToCurrentIndex = 0;\r\n        for (var i = 0; i < this.countsArrayLength; i++) {\r\n            totalToCurrentIndex += this.getCountAtIndex(i);\r\n            if (totalToCurrentIndex >= countAtPercentile) {\r\n                var valueAtIndex = this.valueFromIndex(i);\r\n                return percentile === 0.0\r\n                    ? this.lowestEquivalentValue(valueAtIndex)\r\n                    : this.highestEquivalentValue(valueAtIndex);\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\r\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\r\n    };\r\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\r\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\r\n        var subBucketIndex = index % this.subBucketHalfCount + this.subBucketHalfCount;\r\n        if (bucketIndex < 0) {\r\n            subBucketIndex -= this.subBucketHalfCount;\r\n            bucketIndex = 0;\r\n        }\r\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\r\n    };\r\n    /**\r\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\r\n     */\r\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\r\n        var bucketIndex = this.getBucketIndex(value);\r\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\r\n        return thisValueBaseLevel;\r\n    };\r\n    /**\r\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\r\n     */\r\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\r\n        return this.nextNonEquivalentValue(value) - 1;\r\n    };\r\n    /**\r\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\r\n     */\r\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\r\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\r\n    };\r\n    /**\r\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\r\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The size of the range of values equivalent to the given value.\r\n     */\r\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\r\n        var bucketIndex = this.getBucketIndex(value);\r\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\r\n        var distanceToNextValue = pow(2, this.unitMagnitude +\r\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\r\n        return distanceToNextValue;\r\n    };\r\n    /**\r\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\r\n     * Where \"equivalent\" means that value samples recorded for any two\r\n     * equivalent values are counted in a common total count.\r\n     *\r\n     * @param value The given value\r\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\r\n     */\r\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\r\n        return (this.lowestEquivalentValue(value) +\r\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\r\n    };\r\n    /**\r\n     * Get the computed mean value of all recorded values in the histogram\r\n     *\r\n     * @return the mean value (in value units) of the histogram data\r\n     */\r\n    AbstractHistogram.prototype.getMean = function () {\r\n        if (this.getTotalCount() === 0) {\r\n            return 0;\r\n        }\r\n        this.recordedValuesIterator.reset();\r\n        var totalValue = 0;\r\n        while (this.recordedValuesIterator.hasNext()) {\r\n            var iterationValue = this.recordedValuesIterator.next();\r\n            totalValue +=\r\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\r\n                    iterationValue.countAtValueIteratedTo;\r\n        }\r\n        return totalValue * 1.0 / this.getTotalCount();\r\n    };\r\n    /**\r\n     * Get the computed standard deviation of all recorded values in the histogram\r\n     *\r\n     * @return the standard deviation (in value units) of the histogram data\r\n     */\r\n    AbstractHistogram.prototype.getStdDeviation = function () {\r\n        if (this.getTotalCount() === 0) {\r\n            return 0;\r\n        }\r\n        var mean = this.getMean();\r\n        var geometric_deviation_total = 0.0;\r\n        this.recordedValuesIterator.reset();\r\n        while (this.recordedValuesIterator.hasNext()) {\r\n            var iterationValue = this.recordedValuesIterator.next();\r\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\r\n            geometric_deviation_total +=\r\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\r\n        }\r\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\r\n        return std_deviation;\r\n    };\r\n    /**\r\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\r\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\r\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\r\n     *\r\n     * @param printStream    Stream into which the distribution will be output\r\n     * <p>\r\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\r\n     * <p>\r\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\r\n     *                                     output\r\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\r\n     */\r\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\r\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\r\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\r\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\r\n        var result = \"\";\r\n        if (useCsvFormat) {\r\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\r\n        }\r\n        else {\r\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\r\n        }\r\n        var iterator = this.percentileIterator;\r\n        iterator.reset(percentileTicksPerHalfDistance);\r\n        var lineFormatter;\r\n        var lastLineFormatter;\r\n        if (useCsvFormat) {\r\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\r\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\r\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\r\n            lineFormatter = function (iterationValue) {\r\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \",\" +\r\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \",\" +\r\n                    iterationValue.totalCountToThisValue +\r\n                    \",\" +\r\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\r\n                    \"\\n\";\r\n            };\r\n            lastLineFormatter = function (iterationValue) {\r\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \",\" +\r\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \",\" +\r\n                    iterationValue.totalCountToThisValue +\r\n                    \",Infinity\\n\";\r\n            };\r\n        }\r\n        else {\r\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\r\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\r\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\r\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\r\n            lineFormatter = function (iterationValue) {\r\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \" \" +\r\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \" \" +\r\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\r\n                    \" \" +\r\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\r\n                    \"\\n\";\r\n            };\r\n            lastLineFormatter = function (iterationValue) {\r\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\r\n                    \" \" +\r\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\r\n                    \" \" +\r\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\r\n                    \"\\n\";\r\n            };\r\n        }\r\n        while (iterator.hasNext()) {\r\n            var iterationValue = iterator.next();\r\n            if (iterationValue.percentileLevelIteratedTo < 100) {\r\n                result += lineFormatter(iterationValue);\r\n            }\r\n            else {\r\n                result += lastLineFormatter(iterationValue);\r\n            }\r\n        }\r\n        if (!useCsvFormat) {\r\n            // Calculate and output mean and std. deviation.\r\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\r\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\r\n            // response time distribution associated with GC pauses). However, reporting these numbers\r\n            // can be very useful for contrasting with the detailed percentile distribution\r\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\r\n            // percentile distributions where results fall many tens or even hundreds of standard\r\n            // deviations away from the mean - such results simply indicate that the data sampled\r\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\r\n            // deviation metric is a useless indicator.\r\n            //\r\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\r\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\r\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\r\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\r\n            var intFormatter = formatters_1.integerFormatter(12);\r\n            var totalCount = intFormatter(this.getTotalCount());\r\n            var bucketCount = intFormatter(this.bucketCount);\r\n            var subBucketCount = intFormatter(this.subBucketCount);\r\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\r\n     *\r\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\r\n     */\r\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\r\n        return this._getEstimatedFootprintInBytes();\r\n    };\r\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n        this.recordSingleValue(value);\r\n        if (expectedIntervalBetweenValueSamples <= 0) {\r\n            return;\r\n        }\r\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\r\n            this.recordSingleValue(missingValue);\r\n        }\r\n    };\r\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\r\n        var countsIndex = this.countsArrayIndex(value);\r\n        if (countsIndex >= this.countsArrayLength) {\r\n            this.handleRecordException(count, value);\r\n        }\r\n        else {\r\n            this.addToCountAtIndex(countsIndex, count);\r\n        }\r\n        this.updateMinAndMax(value);\r\n        this.addToTotalCount(count);\r\n    };\r\n    /**\r\n     * Record a value in the histogram (adding to the value's current count)\r\n     *\r\n     * @param value The value to be recorded\r\n     * @param count The number of occurrences of this value to record\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\r\n        this.recordCountAtValue(count, value);\r\n    };\r\n    /**\r\n     * Record a value in the histogram.\r\n     * <p>\r\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\r\n     * (down to the expectedIntervalBetweenValueSamples) value records.\r\n     * <p>\r\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\r\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\r\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\r\n     * for the same coordinated omission issue.\r\n     * <p>\r\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\r\n     * important.\r\n     *\r\n     * @param value The value to record\r\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n     *                                           auto-generated value records as appropriate if value is larger\r\n     *                                           than expectedIntervalBetweenValueSamples\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\r\n    };\r\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\r\n        this.recordCountAtValue(count, value);\r\n        if (expectedIntervalBetweenValueSamples <= 0) {\r\n            return;\r\n        }\r\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\r\n            this.recordCountAtValue(count, missingValue);\r\n        }\r\n    };\r\n    /**\r\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\r\n     * <p>\r\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n     * interval between value samples, the values added will include an auto-generated additional series of\r\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\r\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\r\n     *\r\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\r\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\r\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\r\n     * for the same coordinated omission issue.\r\n     * by\r\n     * <p>\r\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\r\n     * important.\r\n     *\r\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\r\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n     *                                           auto-generated value records as appropriate if value is larger\r\n     *                                           than expectedIntervalBetweenValueSamples\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\r\n     */\r\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\r\n        var toHistogram = this;\r\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\r\n        while (otherValues.hasNext()) {\r\n            var v = otherValues.next();\r\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\r\n        }\r\n    };\r\n    /**\r\n     * Add the contents of another histogram to this one.\r\n     * <p>\r\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\r\n     * extended to include the start/end timestamp range of the other histogram.\r\n     *\r\n     * @param otherHistogram The other histogram.\r\n     * @throws (may throw) if values in fromHistogram's are\r\n     * higher than highestTrackableValue.\r\n     */\r\n    AbstractHistogram.prototype.add = function (otherHistogram) {\r\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\r\n        if (highestRecordableValue < otherHistogram.maxValue) {\r\n            if (!this.autoResize) {\r\n                throw \"The other histogram includes values that do not fit in this histogram's range.\";\r\n            }\r\n            this.resize(otherHistogram.maxValue);\r\n        }\r\n        if (this.bucketCount === otherHistogram.bucketCount &&\r\n            this.subBucketCount === otherHistogram.subBucketCount &&\r\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\r\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\r\n            var observedOtherTotalCount = 0;\r\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n                var otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    this.addToCountAtIndex(i, otherCount);\r\n                    observedOtherTotalCount += otherCount;\r\n                }\r\n            }\r\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\r\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\r\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\r\n        }\r\n        else {\r\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\r\n            // so we can't just stream through and add them. Instead, go through the array and add each\r\n            // non-zero value found at it's proper value:\r\n            // Do max value first, to avoid max value updates on each iteration:\r\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\r\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\r\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\r\n            // Record the remaining values, up to but not including the max value:\r\n            for (var i = 0; i < otherMaxIndex; i++) {\r\n                otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\r\n                }\r\n            }\r\n        }\r\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\r\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\r\n    };\r\n    /**\r\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\r\n     *\r\n     * @param value The value for which to provide the recorded count\r\n     * @return The total count of values recorded in the histogram within the value range that is\r\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\r\n     */\r\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\r\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\r\n        return this.getCountAtIndex(index);\r\n    };\r\n    /**\r\n     * Subtract the contents of another histogram from this one.\r\n     * <p>\r\n     * The start/end timestamps of this histogram will remain unchanged.\r\n     *\r\n     * @param otherHistogram The other histogram.\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\r\n     *\r\n     */\r\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\r\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\r\n        if (highestRecordableValue < otherHistogram.maxValue) {\r\n            if (!this.autoResize) {\r\n                throw \"The other histogram includes values that do not fit in this histogram's range.\";\r\n            }\r\n            this.resize(otherHistogram.maxValue);\r\n        }\r\n        if (this.bucketCount === otherHistogram.bucketCount &&\r\n            this.subBucketCount === otherHistogram.subBucketCount &&\r\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\r\n            // optim\r\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\r\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n                var otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    this.addToCountAtIndex(i, -otherCount);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\r\n                var otherCount = otherHistogram.getCountAtIndex(i);\r\n                if (otherCount > 0) {\r\n                    var otherValue = otherHistogram.valueFromIndex(i);\r\n                    if (this.getCountAtValue(otherValue) < otherCount) {\r\n                        throw \"otherHistogram count (\" +\r\n                            otherCount +\r\n                            \") at value \" +\r\n                            otherValue +\r\n                            \" is larger than this one's (\" +\r\n                            this.getCountAtValue(otherValue) +\r\n                            \")\";\r\n                    }\r\n                    this.recordCountAtValue(-otherCount, otherValue);\r\n                }\r\n            }\r\n        }\r\n        // With subtraction, the max and minNonZero values could have changed:\r\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\r\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\r\n            this.establishInternalTackingValues();\r\n        }\r\n    };\r\n    AbstractHistogram.prototype.fillBufferFromCountsArray = function (buffer) {\r\n        var countsLimit = this.countsArrayIndex(this.maxValue) + 1;\r\n        var srcIndex = 0;\r\n        while (srcIndex < countsLimit) {\r\n            // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\r\n            // while negative values indicate a repeat zero counts.\r\n            var count = this.getCountAtIndex(srcIndex++);\r\n            if (count < 0) {\r\n                throw \"Cannot encode histogram containing negative counts (\" +\r\n                    count +\r\n                    \") at index \" +\r\n                    srcIndex +\r\n                    \", corresponding the value range [\" +\r\n                    this.lowestEquivalentValue(this.valueFromIndex(srcIndex)) +\r\n                    \",\" +\r\n                    this.nextNonEquivalentValue(this.valueFromIndex(srcIndex)) +\r\n                    \")\";\r\n            }\r\n            // Count trailing 0s (which follow this count):\r\n            var zerosCount = 0;\r\n            if (count == 0) {\r\n                zerosCount = 1;\r\n                while (srcIndex < countsLimit && this.getCountAtIndex(srcIndex) == 0) {\r\n                    zerosCount++;\r\n                    srcIndex++;\r\n                }\r\n            }\r\n            if (zerosCount > 1) {\r\n                ZigZagEncoding_1.default.encode(buffer, -zerosCount);\r\n            }\r\n            else {\r\n                ZigZagEncoding_1.default.encode(buffer, count);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Encode this histogram into a ByteBuffer\r\n     * @param buffer The buffer to encode into\r\n     * @return The number of bytes written to the buffer\r\n     */\r\n    AbstractHistogram.prototype.encodeIntoByteBuffer = function (buffer) {\r\n        var initialPosition = buffer.position;\r\n        buffer.putInt32(encodingCookie);\r\n        buffer.putInt32(0); // Placeholder for payload length in bytes.\r\n        buffer.putInt32(1);\r\n        buffer.putInt32(this.numberOfSignificantValueDigits);\r\n        buffer.putInt64(this.lowestDiscernibleValue);\r\n        buffer.putInt64(this.highestTrackableValue);\r\n        buffer.putInt64(1);\r\n        var payloadStartPosition = buffer.position;\r\n        this.fillBufferFromCountsArray(buffer);\r\n        var backupIndex = buffer.position;\r\n        buffer.position = initialPosition + 4;\r\n        buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\r\n        buffer.position = backupIndex;\r\n        return backupIndex - initialPosition;\r\n    };\r\n    AbstractHistogram.prototype.fillCountsArrayFromSourceBuffer = function (sourceBuffer, lengthInBytes, wordSizeInBytes) {\r\n        if (wordSizeInBytes != 2 &&\r\n            wordSizeInBytes != 4 &&\r\n            wordSizeInBytes != 8 &&\r\n            wordSizeInBytes != V2maxWordSizeInBytes) {\r\n            throw \"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\r\n                V2maxWordSizeInBytes +\r\n                \") bytes\";\r\n        }\r\n        var dstIndex = 0;\r\n        var endPosition = sourceBuffer.position + lengthInBytes;\r\n        while (sourceBuffer.position < endPosition) {\r\n            var zerosCount = 0;\r\n            var count = ZigZagEncoding_1.default.decode(sourceBuffer);\r\n            if (count < 0) {\r\n                zerosCount = -count;\r\n                dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\r\n            }\r\n            else {\r\n                this.setCountAtIndex(dstIndex++, count);\r\n            }\r\n        }\r\n        return dstIndex; // this is the destination length\r\n    };\r\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\r\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\r\n        this.maxValue = 0;\r\n        this.minNonZeroValue = Number.MAX_VALUE;\r\n        var maxIndex = -1;\r\n        var minNonZeroIndex = -1;\r\n        var observedTotalCount = 0;\r\n        for (var index = 0; index < lengthToCover; index++) {\r\n            var countAtIndex = this.getCountAtIndex(index);\r\n            if (countAtIndex > 0) {\r\n                observedTotalCount += countAtIndex;\r\n                maxIndex = index;\r\n                if (minNonZeroIndex == -1 && index != 0) {\r\n                    minNonZeroIndex = index;\r\n                }\r\n            }\r\n        }\r\n        if (maxIndex >= 0) {\r\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\r\n        }\r\n        if (minNonZeroIndex >= 0) {\r\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\r\n        }\r\n        this.setTotalCount(observedTotalCount);\r\n    };\r\n    AbstractHistogram.getCookieBase = function (cookie) {\r\n        return cookie & ~0xf0;\r\n    };\r\n    AbstractHistogram.getWordSizeInBytesFromCookie = function (cookie) {\r\n        if (this.getCookieBase(cookie) == V2EncodingCookieBase ||\r\n            this.getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\r\n            return V2maxWordSizeInBytes;\r\n        }\r\n        var sizeByte = (cookie & 0xf0) >> 4;\r\n        return sizeByte & 0xe;\r\n    };\r\n    AbstractHistogram.decodeFromByteBuffer = function (buffer, histogramConstr, minBarForHighestTrackableValue) {\r\n        var cookie = buffer.getInt32();\r\n        var payloadLengthInBytes;\r\n        var numberOfSignificantValueDigits;\r\n        var lowestTrackableUnitValue;\r\n        var highestTrackableValue;\r\n        if (this.getCookieBase(cookie) === V2EncodingCookieBase) {\r\n            if (this.getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\r\n                throw \"The buffer does not contain a Histogram (no valid cookie found)\";\r\n            }\r\n            payloadLengthInBytes = buffer.getInt32();\r\n            buffer.getInt32(); // normalizingIndexOffset not used\r\n            numberOfSignificantValueDigits = buffer.getInt32();\r\n            lowestTrackableUnitValue = buffer.getInt64();\r\n            highestTrackableValue = buffer.getInt64();\r\n            buffer.getInt64(); // integerToDoubleValueConversionRatio not used\r\n        }\r\n        else {\r\n            throw \"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\";\r\n        }\r\n        highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\r\n        var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\r\n        var filledLength = histogram.fillCountsArrayFromSourceBuffer(buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\r\n        histogram.establishInternalTackingValues(filledLength);\r\n        return histogram;\r\n    };\r\n    AbstractHistogram.decodeFromCompressedByteBuffer = function (buffer, histogramConstr, minBarForHighestTrackableValue) {\r\n        var initialTargetPosition = buffer.position;\r\n        var cookie = buffer.getInt32();\r\n        if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\r\n            throw \"Encoding not supported, only V2 is supported\";\r\n        }\r\n        var lengthOfCompressedContents = buffer.getInt32();\r\n        var pako = require(\"pako/lib/inflate\");\r\n        var uncompressedBuffer = pako.inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\r\n        return this.decodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\r\n    };\r\n    /**\r\n     * Encode this histogram in compressed form into a byte array\r\n     * @param targetBuffer The buffer to encode into\r\n     * @return The number of bytes written to the array\r\n     */\r\n    AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = function (targetBuffer, compressionLevel) {\r\n        var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\r\n        var uncompressedLength = this.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\r\n        targetBuffer.putInt32(compressedEncodingCookie);\r\n        var pako = require(\"pako/lib/deflate\");\r\n        var compressionOptions = compressionLevel\r\n            ? { level: compressionLevel }\r\n            : {};\r\n        var compressedArray = pako.deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\r\n        targetBuffer.putInt32(compressedArray.byteLength);\r\n        targetBuffer.putArray(compressedArray);\r\n        return targetBuffer.position;\r\n    };\r\n    AbstractHistogram.prototype.reset = function () {\r\n        this.clearCounts();\r\n        this.setTotalCount(0);\r\n        this.startTimeStampMsec = 0;\r\n        this.endTimeStampMsec = 0;\r\n        this.tag = AbstractHistogramBase_1.NO_TAG;\r\n        this.maxValue = 0;\r\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\r\n    };\r\n    return AbstractHistogram;\r\n}(AbstractHistogramBase_1.AbstractHistogramBase));\r\nexports.default = AbstractHistogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\r\nexports.NO_TAG = \"NO TAG\";\r\nvar AbstractHistogramBase = /** @class */ (function (_super) {\r\n    __extends(AbstractHistogramBase, _super);\r\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\r\n    //intermediateUncompressedByteArray : number[] = null;\r\n    /* useless ?\r\n    getIntegerToDoubleValueConversionRatio(): number {\r\n        return this.integerToDoubleValueConversionRatio;\r\n    }\r\n  \r\n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\r\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\r\n    }*/\r\n    function AbstractHistogramBase() {\r\n        var _this = _super.call(this) || this;\r\n        _this.autoResize = false;\r\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\r\n        _this.endTimeStampMsec = 0;\r\n        _this.tag = exports.NO_TAG;\r\n        _this.integerToDoubleValueConversionRatio = 1.0;\r\n        _this.identity = 0;\r\n        _this.highestTrackableValue = 0;\r\n        _this.lowestDiscernibleValue = 0;\r\n        _this.numberOfSignificantValueDigits = 0;\r\n        _this.bucketCount = 0;\r\n        _this.subBucketCount = 0;\r\n        _this.countsArrayLength = 0;\r\n        _this.wordSizeInBytes = 0;\r\n        return _this;\r\n    }\r\n    return AbstractHistogramBase;\r\n}(EncodableHistogram_1.EncodableHistogram));\r\nexports.AbstractHistogramBase = AbstractHistogramBase;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramBase.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EncodableHistogram = /** @class */ (function () {\r\n    function EncodableHistogram() {\r\n    }\r\n    return EncodableHistogram;\r\n}());\r\nexports.EncodableHistogram = EncodableHistogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/EncodableHistogram.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\r\n/**\r\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\r\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\r\n * all recorded histogram values are exhausted.\r\n */\r\nvar RecordedValuesIterator = /** @class */ (function (_super) {\r\n    __extends(RecordedValuesIterator, _super);\r\n    /**\r\n     * @param histogram The histogram this iterator will operate on\r\n     */\r\n    function RecordedValuesIterator(histogram) {\r\n        var _this = _super.call(this) || this;\r\n        _this.doReset(histogram);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\r\n     */\r\n    RecordedValuesIterator.prototype.reset = function () {\r\n        this.doReset(this.histogram);\r\n    };\r\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\r\n        _super.prototype.resetIterator.call(this, histogram);\r\n        this.visitedIndex = -1;\r\n    };\r\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\r\n        this.visitedIndex = this.currentIndex;\r\n    };\r\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\r\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\r\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\r\n    };\r\n    return RecordedValuesIterator;\r\n}(AbstractHistogramIterator_1.default));\r\nexports.default = RecordedValuesIterator;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RecordedValuesIterator.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\r\n/**\r\n * Used for iterating through histogram values.\r\n */\r\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\r\n    function AbstractHistogramIterator() {\r\n        this.currentIterationValue = new HistogramIterationValue_1.default();\r\n    }\r\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\r\n        this.histogram = histogram;\r\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\r\n        this.arrayTotalCount = histogram.getTotalCount();\r\n        this.currentIndex = 0;\r\n        this.currentValueAtIndex = 0;\r\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\r\n        this.prevValueIteratedTo = 0;\r\n        this.totalCountToPrevIndex = 0;\r\n        this.totalCountToCurrentIndex = 0;\r\n        this.totalValueToCurrentIndex = 0;\r\n        this.countAtThisValue = 0;\r\n        this.freshSubBucket = true;\r\n        this.currentIterationValue.reset();\r\n    };\r\n    /**\r\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\r\n     * element rather than throwing an exception.)\r\n     *\r\n     * @return true if the iterator has more elements.\r\n     */\r\n    AbstractHistogramIterator.prototype.hasNext = function () {\r\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\r\n            throw \"Concurrent Modification Exception\";\r\n        }\r\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\r\n    };\r\n    /**\r\n     * Returns the next element in the iteration.\r\n     *\r\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\r\n     */\r\n    AbstractHistogramIterator.prototype.next = function () {\r\n        // Move through the sub buckets and buckets until we hit the next reporting level:\r\n        while (!this.exhaustedSubBuckets()) {\r\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\r\n            if (this.freshSubBucket) {\r\n                // Don't add unless we've incremented since last bucket...\r\n                this.totalCountToCurrentIndex += this.countAtThisValue;\r\n                this.totalValueToCurrentIndex +=\r\n                    this.countAtThisValue *\r\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\r\n                this.freshSubBucket = false;\r\n            }\r\n            if (this.reachedIterationLevel()) {\r\n                var valueIteratedTo = this.getValueIteratedTo();\r\n                Object.assign(this.currentIterationValue, {\r\n                    valueIteratedTo: valueIteratedTo,\r\n                    valueIteratedFrom: this.prevValueIteratedTo,\r\n                    countAtValueIteratedTo: this.countAtThisValue,\r\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\r\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\r\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\r\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\r\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\r\n                });\r\n                this.prevValueIteratedTo = valueIteratedTo;\r\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\r\n                this.incrementIterationLevel();\r\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\r\n                    throw \"Concurrent Modification Exception\";\r\n                }\r\n                return this.currentIterationValue;\r\n            }\r\n            this.incrementSubBucket();\r\n        }\r\n        throw \"Index Out Of Bounds Exception\";\r\n    };\r\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\r\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\r\n    };\r\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\r\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\r\n    };\r\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\r\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\r\n    };\r\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\r\n        return this.currentIndex >= this.histogram.countsArrayLength;\r\n    };\r\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\r\n        this.freshSubBucket = true;\r\n        this.currentIndex++;\r\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\r\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\r\n    };\r\n    return AbstractHistogramIterator;\r\n}());\r\nexports.default = AbstractHistogramIterator;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramIterator.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a value point iterated through in a Histogram, with associated stats.\r\n * <ul>\r\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\r\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\r\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\r\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\r\n * range.</li>\r\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\r\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\r\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\r\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\r\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\r\n * values equal or smaller than valueIteratedTo.</li>\r\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\r\n * equal or smaller than valueIteratedTo.</li>\r\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\r\n * or smaller than valueIteratedTo.</li>\r\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\r\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\r\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\r\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\r\n * range of multiple percentiles in the requested percentile iteration points).</li>\r\n * </ul>\r\n */\r\nvar HistogramIterationValue = /** @class */ (function () {\r\n    function HistogramIterationValue() {\r\n        this.reset();\r\n    }\r\n    HistogramIterationValue.prototype.reset = function () {\r\n        this.valueIteratedTo = 0;\r\n        this.valueIteratedFrom = 0;\r\n        this.countAtValueIteratedTo = 0;\r\n        this.countAddedInThisIterationStep = 0;\r\n        this.totalCountToThisValue = 0;\r\n        this.totalValueToThisValue = 0;\r\n        this.percentile = 0.0;\r\n        this.percentileLevelIteratedTo = 0.0;\r\n    };\r\n    return HistogramIterationValue;\r\n}());\r\nexports.default = HistogramIterationValue;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramIterationValue.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\r\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\r\n/**\r\n * Used for iterating through histogram values according to percentile levels. The iteration is\r\n * performed in steps that start at 0% and reduce their distance to 100% according to the\r\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\r\n * values are exhausted.\r\n */\r\nvar PercentileIterator = /** @class */ (function (_super) {\r\n    __extends(PercentileIterator, _super);\r\n    /**\r\n       * @param histogram The histogram this iterator will operate on\r\n       * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\r\n       */\r\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\r\n        var _this = _super.call(this) || this;\r\n        _this.percentileTicksPerHalfDistance = 0;\r\n        _this.percentileLevelToIterateTo = 0;\r\n        _this.percentileLevelToIterateFrom = 0;\r\n        _this.reachedLastRecordedValue = false;\r\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\r\n        return _this;\r\n    }\r\n    /**\r\n       * Reset iterator for re-use in a fresh iteration over the same histogram data set.\r\n       *\r\n       * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\r\n       */\r\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\r\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\r\n    };\r\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\r\n        _super.prototype.resetIterator.call(this, histogram);\r\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\r\n        this.percentileLevelToIterateTo = 0;\r\n        this.percentileLevelToIterateFrom = 0;\r\n        this.reachedLastRecordedValue = false;\r\n    };\r\n    PercentileIterator.prototype.hasNext = function () {\r\n        if (_super.prototype.hasNext.call(this))\r\n            return true;\r\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\r\n            this.percentileLevelToIterateTo = 100;\r\n            this.reachedLastRecordedValue = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    PercentileIterator.prototype.incrementIterationLevel = function () {\r\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\r\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\r\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\r\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\r\n        // steps are much easier to browse through in a percentile distribution output, for example.\r\n        //\r\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\r\n        // by at the current scale. The scale is detemined by the percentile level we are\r\n        // iterating to. The following math determines the tick size for the current scale,\r\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\r\n        // [from either 0% or from the previous half-distance]. When that half-distance is\r\n        // crossed, the scale changes and the tick size is effectively cut in half.\r\n        // percentileTicksPerHalfDistance = 5\r\n        // percentileReportingTicks = 10,\r\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\r\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\r\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\r\n    };\r\n    PercentileIterator.prototype.reachedIterationLevel = function () {\r\n        if (this.countAtThisValue === 0) {\r\n            return false;\r\n        }\r\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\r\n        return currentPercentile >= this.percentileLevelToIterateTo;\r\n    };\r\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\r\n        return this.percentileLevelToIterateTo;\r\n    };\r\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\r\n        return this.percentileLevelToIterateFrom;\r\n    };\r\n    return PercentileIterator;\r\n}(AbstractHistogramIterator_1.default));\r\nexports.default = PercentileIterator;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PercentileIterator.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar leftPadding = function (size) {\r\n    return function (input) {\r\n        if (input.length < size) {\r\n            return \" \".repeat(size - input.length) + input;\r\n        }\r\n        return input;\r\n    };\r\n};\r\nexports.integerFormatter = function (size) {\r\n    var padding = leftPadding(size);\r\n    return function (integer) { return padding(\"\" + integer); };\r\n};\r\nexports.floatFormatter = function (size, fractionDigits) {\r\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\r\n        maximumFractionDigits: fractionDigits,\r\n        minimumFractionDigits: fractionDigits,\r\n        useGrouping: false\r\n    });\r\n    var padding = leftPadding(size);\r\n    return function (float) { return padding(numberFormatter.format(float)); };\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatters.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar pow = Math.pow, floor = Math.floor;\r\nvar TWO_POW_7 = pow(2, 7);\r\nvar TWO_POW_14 = pow(2, 14);\r\nvar TWO_POW_21 = pow(2, 21);\r\nvar TWO_POW_28 = pow(2, 28);\r\nvar TWO_POW_35 = pow(2, 35);\r\nvar TWO_POW_42 = pow(2, 42);\r\nvar TWO_POW_49 = pow(2, 49);\r\nvar TWO_POW_56 = pow(2, 56);\r\n/**\r\n * This class provides encoding and decoding methods for writing and reading\r\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\r\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\r\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\r\n * allows small (closer to zero) negative values to use fewer bytes. Details\r\n * on both LEB128 and ZigZag can be readily found elsewhere.\r\n *\r\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\r\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\r\n * value can take up to 10 bytes in the stream, where this variant's encoding\r\n * of a 64 bit values will max out at 9 bytes.\r\n *\r\n * As such, this encoder/decoder should NOT be used for encoding or decoding\r\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\r\n */\r\nvar ZigZagEncoding = /** @class */ (function () {\r\n    function ZigZagEncoding() {\r\n    }\r\n    /**\r\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\r\n     * (negative numbers not supported)\r\n     * @param buffer the buffer to write to\r\n     * @param value  the value to write to the buffer\r\n     */\r\n    ZigZagEncoding.encode = function (buffer, value) {\r\n        if (value >= 0) {\r\n            value = value * 2;\r\n        }\r\n        else {\r\n            value = -value * 2 - 1;\r\n        }\r\n        if (value < TWO_POW_7) {\r\n            buffer.put(value);\r\n        }\r\n        else {\r\n            buffer.put(value % 0x80 + 0x80);\r\n            if (value < TWO_POW_14) {\r\n                buffer.put(floor(value / TWO_POW_7));\r\n            }\r\n            else {\r\n                buffer.put(floor(value / TWO_POW_7) + 0x80);\r\n                if (value < TWO_POW_21) {\r\n                    buffer.put(floor(value / TWO_POW_14));\r\n                }\r\n                else {\r\n                    buffer.put(floor(value / TWO_POW_14) + 0x80);\r\n                    if (value < TWO_POW_28) {\r\n                        buffer.put(floor(value / TWO_POW_21));\r\n                    }\r\n                    else {\r\n                        buffer.put(floor(value / TWO_POW_21) + 0x80);\r\n                        if (value < TWO_POW_35) {\r\n                            buffer.put(floor(value / TWO_POW_28));\r\n                        }\r\n                        else {\r\n                            buffer.put(floor(value / TWO_POW_28) + 0x80);\r\n                            if (value < TWO_POW_42) {\r\n                                buffer.put(floor(value / TWO_POW_35));\r\n                            }\r\n                            else {\r\n                                buffer.put(floor(value / TWO_POW_35) + 0x80);\r\n                                if (value < TWO_POW_49) {\r\n                                    buffer.put(floor(value / TWO_POW_42));\r\n                                }\r\n                                else {\r\n                                    buffer.put(floor(value / TWO_POW_42) + 0x80);\r\n                                    if (value < TWO_POW_56) {\r\n                                        buffer.put(floor(value / TWO_POW_49));\r\n                                    }\r\n                                    else {\r\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\r\n                                        buffer.put(floor(value / TWO_POW_56));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\r\n     * (negative numbers not supported)\r\n     * @param buffer the buffer to read from\r\n     * @return the value read from the buffer\r\n     */\r\n    ZigZagEncoding.decode = function (buffer) {\r\n        var v = buffer.get();\r\n        var value = v & 0x7f;\r\n        if ((v & 0x80) != 0) {\r\n            v = buffer.get();\r\n            value += (v & 0x7f) * TWO_POW_7;\r\n            if ((v & 0x80) != 0) {\r\n                v = buffer.get();\r\n                value += (v & 0x7f) * TWO_POW_14;\r\n                if ((v & 0x80) != 0) {\r\n                    v = buffer.get();\r\n                    value += (v & 0x7f) * TWO_POW_21;\r\n                    if ((v & 0x80) != 0) {\r\n                        v = buffer.get();\r\n                        value += (v & 0x7f) * TWO_POW_28;\r\n                        if ((v & 0x80) != 0) {\r\n                            v = buffer.get();\r\n                            value += (v & 0x7f) * TWO_POW_35;\r\n                            if ((v & 0x80) != 0) {\r\n                                v = buffer.get();\r\n                                value += (v & 0x7f) * TWO_POW_42;\r\n                                if ((v & 0x80) != 0) {\r\n                                    v = buffer.get();\r\n                                    value += (v & 0x7f) * TWO_POW_49;\r\n                                    if ((v & 0x80) != 0) {\r\n                                        v = buffer.get();\r\n                                        value += (v & 0x7f) * TWO_POW_56;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (value % 2 === 0) {\r\n            value = value / 2;\r\n        }\r\n        else {\r\n            value = -(value + 1) / 2;\r\n        }\r\n        return value;\r\n    };\r\n    return ZigZagEncoding;\r\n}());\r\nexports.default = ZigZagEncoding;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ZigZagEncoding.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\r\nexports.default = ulp;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ulp.ts\n// module id = 13\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pako\"\n// module id = 14\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int16Histogram = /** @class */ (function (_super) {\r\n    __extends(Int16Histogram, _super);\r\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Uint16Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Int16Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Uint16Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Int16Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Int16Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Int16Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Int16Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + 2 * this.counts.length;\r\n    };\r\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Int16Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Int16Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int16Histogram.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int32Histogram = /** @class */ (function (_super) {\r\n    __extends(Int32Histogram, _super);\r\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Uint32Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Int32Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Uint32Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Int32Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Int32Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Int32Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Int32Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + 4 * this.counts.length;\r\n    };\r\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Int32Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Int32Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int32Histogram.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Float64Histogram = /** @class */ (function (_super) {\r\n    __extends(Float64Histogram, _super);\r\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\r\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\r\n        _this.totalCount = 0;\r\n        _this.counts = new Float64Array(_this.countsArrayLength);\r\n        return _this;\r\n    }\r\n    Float64Histogram.prototype.clearCounts = function () {\r\n        this.counts.fill(0);\r\n    };\r\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + 1;\r\n        if (newCount < 0) {\r\n            throw newCount + \" would overflow short integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\r\n        var currentCount = this.counts[index];\r\n        var newCount = currentCount + value;\r\n        if (newCount < Number.MIN_SAFE_INTEGER ||\r\n            newCount > Number.MAX_SAFE_INTEGER) {\r\n            throw newCount + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = newCount;\r\n    };\r\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\r\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\r\n            throw value + \" would overflow integer count\";\r\n        }\r\n        this.counts[index] = value;\r\n    };\r\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\r\n        this.establishSize(newHighestTrackableValue);\r\n        var newCounts = new Float64Array(this.countsArrayLength);\r\n        newCounts.set(this.counts);\r\n        this.counts = newCounts;\r\n    };\r\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\r\n    Float64Histogram.prototype.incrementTotalCount = function () {\r\n        this.totalCount++;\r\n    };\r\n    Float64Histogram.prototype.addToTotalCount = function (value) {\r\n        this.totalCount += value;\r\n    };\r\n    Float64Histogram.prototype.setTotalCount = function (value) {\r\n        this.totalCount = value;\r\n    };\r\n    Float64Histogram.prototype.getTotalCount = function () {\r\n        return this.totalCount;\r\n    };\r\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\r\n        return this.counts[index];\r\n    };\r\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\r\n        return 512 + 8 * this.counts.length;\r\n    };\r\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\r\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\r\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\r\n        return copy;\r\n    };\r\n    return Float64Histogram;\r\n}(AbstractHistogram_1.default));\r\nexports.default = Float64Histogram;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Float64Histogram.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\r\nvar encoding_1 = require(\"./encoding\");\r\nvar TAG_PREFIX = \"Tag=\";\r\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\r\n/**\r\n * A histogram log reader.\r\n * <p>\r\n * Histogram logs are used to capture full fidelity, per-time-interval\r\n * histograms of a recorded value.\r\n * <p>\r\n * For example, a histogram log can be used to capture high fidelity\r\n * reaction-time logs for some measured system or subsystem component.\r\n * Such a log would capture a full reaction time histogram for each\r\n * logged interval, and could be used to later reconstruct a full\r\n * HdrHistogram of the measured reaction time behavior for any arbitrary\r\n * time range within the log, by adding [only] the relevant interval\r\n * histograms.\r\n * <h3>Histogram log format:</h3>\r\n * A histogram log file consists of text lines. Lines beginning with\r\n * the \"#\" character are optional and treated as comments. Lines\r\n * containing the legend (starting with \"Timestamp\") are also optional\r\n * and ignored in parsing the histogram log. All other lines must\r\n * be valid interval description lines. Text fields are delimited by\r\n * commas, spaces.\r\n * <p>\r\n * A valid interval description line contains an optional Tag=tagString\r\n * text field, followed by an interval description.\r\n * <p>\r\n * A valid interval description must contain exactly four text fields:\r\n * <ul>\r\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\r\n * representing the start timestamp of the interval in seconds.</li>\r\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\r\n * representing the length of the interval in seconds.</li>\r\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\r\n * which generally represents the maximum value of the interval histogram.</li>\r\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\r\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\r\n * </ul>\r\n * The log file may contain an optional indication of a starting time. Starting time\r\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\r\n * by a number parse-able as a double, representing the start time (in seconds)\r\n * that may be added to timestamps in the file to determine an absolute\r\n * timestamp (e.g. since the epoch) for each interval.\r\n */\r\nvar HistogramLogReader = /** @class */ (function () {\r\n    function HistogramLogReader(logContent) {\r\n        this.lines = splitLines(logContent);\r\n        this.currentLineIndex = 0;\r\n    }\r\n    /**\r\n     * Read the next interval histogram from the log. Returns a Histogram object if\r\n     * an interval line was found, or null if not.\r\n     * <p>Upon encountering any unexpected format errors in reading the next interval\r\n     * from the file, this method will return a null.\r\n     * @return a DecodedInterval, or a null if no appropriate interval found\r\n     */\r\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\r\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\r\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\r\n        while (this.currentLineIndex < this.lines.length) {\r\n            var currentLine = this.lines[this.currentLineIndex];\r\n            this.currentLineIndex++;\r\n            if (currentLine.startsWith(\"#[StartTime:\")) {\r\n                this.parseStartTimeFromLine(currentLine);\r\n            }\r\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\r\n                this.parseBaseTimeFromLine(currentLine);\r\n            }\r\n            else if (currentLine.startsWith(\"#\") ||\r\n                currentLine.startsWith('\"StartTimestamp\"')) {\r\n                // skip legend & meta data for now\r\n            }\r\n            else if (currentLine.includes(\",\")) {\r\n                var tokens = currentLine.split(\",\");\r\n                var firstToken = tokens[0];\r\n                var tag = void 0;\r\n                if (firstToken.startsWith(TAG_PREFIX)) {\r\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\r\n                    tokens.shift();\r\n                }\r\n                else {\r\n                    tag = AbstractHistogramBase_1.NO_TAG;\r\n                }\r\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\r\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\r\n                if (!this.baseTimeSec) {\r\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\r\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\r\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\r\n                        // StartTime), we assume that timestamps in the log are not absolute\r\n                        this.baseTimeSec = this.startTimeSec;\r\n                    }\r\n                    else {\r\n                        // Timestamps are absolute\r\n                        this.baseTimeSec = 0.0;\r\n                    }\r\n                }\r\n                if (rangeEndTimeSec < logTimeStampInSec) {\r\n                    return null;\r\n                }\r\n                if (logTimeStampInSec < rangeStartTimeSec) {\r\n                    continue;\r\n                }\r\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram);\r\n                histogram.startTimeStampMsec =\r\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\r\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\r\n                histogram.endTimeStampMsec =\r\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\r\n                histogram.tag = tag;\r\n                return histogram;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\r\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\r\n    };\r\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\r\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\r\n    };\r\n    return HistogramLogReader;\r\n}());\r\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\r\nvar shouldIncludeNoTag = function (lines) {\r\n    return lines.find(function (line) {\r\n        return !line.startsWith(\"#\") &&\r\n            !line.startsWith('\"') &&\r\n            !line.startsWith(TAG_PREFIX) &&\r\n            line.includes(\",\");\r\n    });\r\n};\r\nexports.listTags = function (content) {\r\n    var lines = splitLines(content);\r\n    var tags = lines\r\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\r\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\r\n    var tagsWithoutDuplicates = new Set(tags);\r\n    var result = Array.from(tagsWithoutDuplicates);\r\n    if (shouldIncludeNoTag(lines)) {\r\n        result.unshift(\"NO TAG\");\r\n    }\r\n    return result;\r\n};\r\nexports.default = HistogramLogReader;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogReader.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\r\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\r\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\r\nvar base64 = require(\"base64-js\");\r\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\r\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\r\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\r\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String));\r\n    return AbstractHistogram_1.default.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\r\n};\r\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\r\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\r\n    var buffer = ByteBuffer_1.default.allocate();\r\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\r\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\r\n    return base64.fromByteArray(encodedBuffer);\r\n};\r\nexports.encodeIntoBase64String = encodeIntoBase64String;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encoding.ts\n// module id = 19\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 20\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\r\nvar encoding_1 = require(\"./encoding\");\r\nvar formatters_1 = require(\"./formatters\");\r\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\r\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\r\nvar HistogramLogWriter = /** @class */ (function () {\r\n    function HistogramLogWriter(log) {\r\n        this.log = log;\r\n        /**\r\n           * Base time to subtract from supplied histogram start/end timestamps when\r\n           * logging based on histogram timestamps.\r\n           * Base time is expected to be in msec since the epoch, as histogram start/end times\r\n           * are typically stamped with absolute times in msec since the epoch.\r\n           */\r\n        this.baseTime = 0;\r\n    }\r\n    /**\r\n       * Output an interval histogram, with the given timestamp information and the [optional] tag\r\n       * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\r\n       * specified timestamp information will be used, and the timestamp information in the actual\r\n       * histogram will be ignored).\r\n       * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\r\n       * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\r\n       * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\r\n       * @param histogram The interval histogram to log.\r\n       * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\r\n       */\r\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\r\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\r\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\r\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\r\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\r\n        var start = timeFormatter(startTimeStampSec);\r\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\r\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\r\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\r\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\r\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\r\n        }\r\n        else {\r\n            this.log(lineContent);\r\n        }\r\n    };\r\n    /**\r\n       * Log a comment to the log.\r\n       * Comments will be preceded with with the '#' character.\r\n       * @param comment the comment string.\r\n       */\r\n    HistogramLogWriter.prototype.outputComment = function (comment) {\r\n        this.log(\"#\" + comment + \"\\n\");\r\n    };\r\n    /**\r\n       * Log a start time in the log.\r\n       * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\r\n       */\r\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\r\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\r\n    };\r\n    /**\r\n       * Output a legend line to the log.\r\n       */\r\n    HistogramLogWriter.prototype.outputLegend = function () {\r\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\r\n    };\r\n    /**\r\n       * Output a log format version to the log.\r\n       */\r\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\r\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\r\n    };\r\n    return HistogramLogWriter;\r\n}());\r\nexports.default = HistogramLogWriter;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogWriter.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\r\n/*\r\n * This is a TypeScript port of the original Java version, which was written by\r\n * Gil Tene as described in\r\n * https://github.com/HdrHistogram/HdrHistogram\r\n * and released to the public domain, as explained at\r\n * http://creativecommons.org/publicdomain/zero/1.0/\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\r\n/**\r\n * Records integer values, and provides stable interval {@link Histogram} samples from\r\n * live recorded data without interrupting or stalling active recording of values. Each interval\r\n * histogram provided contains all value counts accumulated since the previous interval histogram\r\n * was taken.\r\n * <p>\r\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\r\n * <p>\r\n * {@link Recorder} supports concurrent\r\n * {@link Recorder#recordValue} or\r\n * {@link Recorder#recordValueWithExpectedInterval} calls.\r\n *\r\n */\r\nvar Recorder = /** @class */ (function () {\r\n    /**\r\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\r\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\r\n     *\r\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\r\n     *                                       decimal digits to which the histogram will maintain value resolution\r\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\r\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\r\n     */\r\n    function Recorder(numberOfSignificantValueDigits, clock) {\r\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\r\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\r\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\r\n        this.clock = clock;\r\n        this.activeHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\r\n        Recorder.idGenerator++;\r\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\r\n        this.activeHistogram.startTimeStampMsec = clock();\r\n    }\r\n    /**\r\n     * Record a value in the histogram\r\n     *\r\n     * @param value The value to be recorded\r\n     * @throws may throw Error if value is exceeds highestTrackableValue\r\n     */\r\n    Recorder.prototype.recordValue = function (value) {\r\n        this.activeHistogram.recordValue(value);\r\n    };\r\n    /**\r\n     * Record a value in the histogram (adding to the value's current count)\r\n     *\r\n     * @param value The value to be recorded\r\n     * @param count The number of occurrences of this value to record\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    Recorder.prototype.recordValueWithCount = function (value, count) {\r\n        this.activeHistogram.recordValueWithCount(value, count);\r\n    };\r\n    /**\r\n     * Record a value\r\n     * <p>\r\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\r\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\r\n     * (down to the expectedIntervalBetweenValueSamples) value records.\r\n     * <p>\r\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\r\n     * for more explanations about coordinated omission and expected interval correction.\r\n     *      *\r\n     * @param value The value to record\r\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\r\n     *                                           auto-generated value records as appropriate if value is larger\r\n     *                                           than expectedIntervalBetweenValueSamples\r\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\r\n     */\r\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\r\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\r\n    };\r\n    /**\r\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\r\n     * accumulated since the last interval histogram was taken.\r\n     * <p>\r\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n     * getIntervalHistogram(histogramToRecycle)}\r\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\r\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\r\n     * {@link Recorder#getIntervalHistogram()} and\r\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\r\n     * {@code histogramToRecycle} must\r\n     * be either be null or an interval histogram returned by a previous call to\r\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n     * getIntervalHistogram(histogramToRecycle)} or\r\n     * {@link Recorder#getIntervalHistogram()}.\r\n     * <p>\r\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\r\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\r\n     * <p>\r\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\r\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\r\n     * counts for the next interval\r\n     *\r\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\r\n     *                           copy operations.\r\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\r\n     */\r\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\r\n        if (histogramToRecycle) {\r\n            var histogramToRecycleWithId = histogramToRecycle;\r\n            if (histogramToRecycleWithId.containingInstanceId !==\r\n                this.activeHistogram.containingInstanceId) {\r\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\r\n            }\r\n        }\r\n        this.inactiveHistogram = histogramToRecycle;\r\n        this.performIntervalSample();\r\n        var sampledHistogram = this.inactiveHistogram;\r\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\r\n        return sampledHistogram;\r\n    };\r\n    /**\r\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\r\n     * was taken) into {@code targetHistogram}.\r\n     *\r\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\r\n     * the value counts, and start accumulating value counts for the next interval.\r\n     *\r\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\r\n     */\r\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\r\n        this.performIntervalSample();\r\n        if (this.inactiveHistogram) {\r\n            targetHistogram.add(this.inactiveHistogram);\r\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\r\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\r\n        }\r\n    };\r\n    /**\r\n     * Reset any value counts accumulated thus far.\r\n     */\r\n    Recorder.prototype.reset = function () {\r\n        this.activeHistogram.reset();\r\n        this.activeHistogram.startTimeStampMsec = this.clock();\r\n    };\r\n    Recorder.prototype.performIntervalSample = function () {\r\n        if (!this.inactiveHistogram) {\r\n            this.inactiveHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\r\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\r\n        }\r\n        this.inactiveHistogram.reset();\r\n        var tempHistogram = this.activeHistogram;\r\n        this.activeHistogram = this.inactiveHistogram;\r\n        this.inactiveHistogram = tempHistogram;\r\n        var currentTimeInMs = this.clock();\r\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\r\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\r\n    };\r\n    Recorder.idGenerator = 0;\r\n    return Recorder;\r\n}());\r\nexports.default = Recorder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Recorder.ts\n// module id = 22\n// module chunks = 0"],"sourceRoot":""}